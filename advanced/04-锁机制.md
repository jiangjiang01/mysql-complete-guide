# 04-锁机制

> 对应课程：第06-08讲（全局锁、表锁、行锁、事务隔离实现）
> 学习时间：2-3小时
> 前置要求：已完成03-索引原理学习

---

## 核心知识点

### MySQL锁分类

```
MySQL锁
├── 全局锁（FTWRL）
├── 表级锁
│   ├── 表锁（lock tables）
│   └── 元数据锁（MDL锁）
└── 行锁
    ├── 记录锁（Record Lock）
    ├── 间隙锁（Gap Lock）
    └── Next-Key Lock（记录锁+间隙锁）
```

### 第06讲：全局锁和表锁

#### 全局锁（FTWRL - Flush Tables With Read Lock）

**用途**：全库逻辑备份
**语法**：`FLUSH TABLES WITH READ LOCK`
**影响**：整个数据库只读，所有DML和DDL语句被阻塞
**问题**：
- 业务停摆
- 主从延迟

**替代方案**：
- mysqldump --single-transaction（推荐，支持InnoDB）
- MVCC一致性读视图

#### 表锁

**语法**：
```sql
LOCK TABLES t1 READ, t2 WRITE;
UNLOCK TABLES;
```

**特点**：
- READ锁：所有会话可读，不可写
- WRITE锁：只有持锁会话可读写

**问题**：粒度太大，并发性差，InnoDB很少使用

#### MDL锁（Metadata Lock）

**作用**：保护表结构
**自动加锁**：
- DML语句：加MDL读锁
- DDL语句：加MDL写锁

**问题场景**：
- 长事务持有MDL读锁
- DDL被阻塞，后续所有DML被阻塞
- 导致数据库hang住

**解决方案**：
- 避免长事务
- DDL使用nowait/wait N语法

### 第07讲：行锁

#### InnoDB行锁类型

1. **记录锁（Record Lock）**：锁住索引记录
2. **间隙锁（Gap Lock）**：锁住索引记录之间的间隙
3. **Next-Key Lock**：记录锁+间隙锁

**间隙锁的作用**：
- 防止幻读
- 只在REPEATABLE READ级别生效

**行锁加锁规则**（REPEATABLE READ级别）：
1. 加锁基本单位是Next-Key Lock（左开右闭区间）
2. 查找过程中访问到的对象才会加锁
3. 索引上的等值查询，给唯一索引加锁时，Next-Key Lock退化为Record Lock
4. 索引上的等值查询，向右遍历且最后一个值不满足条件时，Next-Key Lock退化为Gap Lock

#### 两阶段锁协议

- **加锁阶段**：事务开始后，随时可以加锁
- **解锁阶段**：第一次释放锁后，只能释放锁，不能再加锁
- **InnoDB行锁**：在COMMIT时统一释放

**优化建议**：把最可能造成冲突的锁尽量往后放

### 第08讲：事务到底是隔离的还是不隔离的？

#### 当前读 vs 快照读

**快照读**：普通SELECT，读取MVCC版本
```sql
SELECT * FROM t WHERE id = 1;
```

**当前读**：读取最新版本，加锁
```sql
SELECT * FROM t WHERE id = 1 FOR UPDATE;  -- 加排他锁
SELECT * FROM t WHERE id = 1 LOCK IN SHARE MODE;  -- 加共享锁
INSERT / UPDATE / DELETE  -- 加排他锁
```

#### 事务视图

- **REPEATABLE READ**：事务启动时创建一致性视图
- **READ COMMITTED**：每条SQL执行时创建视图

**结论**：
- 快照读：事务是隔离的（看历史版本）
- 当前读：事务不是完全隔离的（需要加锁）

---

## 实操练习

### 第06讲实操：全局锁和表锁

#### 1. 全局锁演示

```sql
-- === 窗口A ===
USE mysql_study;

-- 加全局锁
FLUSH TABLES WITH READ LOCK;

-- 此时整个数据库变为只读状态
SELECT * FROM users LIMIT 10;  -- 可以读

-- 等待窗口B...
```

```sql
-- === 窗口B ===
USE mysql_study;

-- 尝试写入
INSERT INTO users (name, age, email) VALUES ('test', 30, 'test@example.com');
-- 阻塞！等待窗口A释放全局锁...

-- 窗口A执行UNLOCK后才能继续
```

```sql
-- === 窗口A ===
-- 释放全局锁
UNLOCK TABLES;

-- 窗口B的写入操作继续执行
```

#### 2. 使用mysqldump进行一致性备份（推荐）

```bash
# 在命令行执行（不是MySQL客户端）

# InnoDB表使用--single-transaction（推荐）
mysqldump -uroot -p \
  --single-transaction \
  --master-data=2 \
  mysql_study > backup.sql

# 说明：
# --single-transaction: 利用MVCC获取一致性视图，不阻塞业务
# --master-data=2: 记录binlog位置（注释形式）

# 不支持事务的表（如MyISAM）才需要用--lock-all-tables
mysqldump -uroot -p \
  --lock-all-tables \
  mysql_study > backup.sql
```

#### 3. 表锁演示

```sql
-- === 窗口A ===
USE mysql_study;

-- 加表读锁
LOCK TABLES users READ;

-- 可以读
SELECT * FROM users LIMIT 10;

-- 不能写
UPDATE users SET age = 30 WHERE id = 1;
-- ERROR: Table 'users' was locked with a READ lock

-- 不能访问其他表
SELECT * FROM account;
-- ERROR: Table 'account' was not locked
```

```sql
-- === 窗口B ===
-- 可以读
SELECT * FROM users LIMIT 10;

-- 写入被阻塞
UPDATE users SET age = 30 WHERE id = 1;
-- 阻塞，等待窗口A释放锁...
```

```sql
-- === 窗口A ===
-- 释放表锁
UNLOCK TABLES;

-- 窗口B的写入继续执行
```

#### 4. MDL锁演示（重要！）

```sql
-- === 窗口A ===
USE mysql_study;

-- 开启事务并执行查询（获取MDL读锁）
START TRANSACTION;
SELECT * FROM users WHERE id = 1;

-- 不要COMMIT，保持事务...
```

```sql
-- === 窗口B ===
-- 尝试修改表结构（需要MDL写锁）
ALTER TABLE users ADD COLUMN phone VARCHAR(20);

-- 阻塞！等待窗口A释放MDL读锁...
```

```sql
-- === 窗口C（新开一个窗口）===
-- 尝试查询
SELECT * FROM users WHERE id = 2;

-- 也被阻塞！因为MDL写锁在等待队列中，阻塞了后续的MDL读锁
```

```sql
-- === 窗口A ===
-- 提交事务，释放MDL读锁
COMMIT;

-- 窗口B的DDL继续执行
-- 窗口C的查询继续执行
```

#### 5. 查看MDL锁等待

```sql
-- 查看当前的MDL锁
SELECT * FROM performance_schema.metadata_locks;

-- 查看等待MDL锁的线程
SELECT
    locked_table,
    waiting_pid,
    waiting_lock_type,
    blocking_pid,
    blocking_lock_type
FROM sys.schema_table_lock_waits;
```

#### 6. 安全的DDL操作

```sql
-- MySQL 5.7+支持NOWAIT和WAIT N语法（MariaDB）

-- 方式1：设置超时（推荐）
SET SESSION lock_wait_timeout = 5;  -- 5秒超时

ALTER TABLE users ADD COLUMN phone VARCHAR(20);
-- 如果5秒内获取不到锁，报错而不是无限等待

-- 方式2：在低峰期执行DDL

-- 方式3：使用在线DDL工具（如pt-online-schema-change）
```

### 第07讲实操：行锁

#### 7. 准备测试数据

```sql
USE mysql_study;

CREATE TABLE lock_test (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    KEY idx_age (age)
) ENGINE=InnoDB;

INSERT INTO lock_test VALUES
(1, 'a', 10),
(5, 'b', 20),
(10, 'c', 30),
(15, 'd', 40);
```

#### 8. 记录锁（Record Lock）演示

```sql
-- === 窗口A ===
START TRANSACTION;

-- 通过主键等值查询（加记录锁）
SELECT * FROM lock_test WHERE id = 5 FOR UPDATE;

-- 等待窗口B...
```

```sql
-- === 窗口B ===
START TRANSACTION;

-- 更新同一行（被阻塞）
UPDATE lock_test SET name = 'bbb' WHERE id = 5;
-- 阻塞！

-- 更新其他行（不阻塞）
UPDATE lock_test SET name = 'aaa' WHERE id = 1;
-- 成功！
```

```sql
-- === 窗口A ===
COMMIT;

-- 窗口B的更新继续执行
```

#### 9. 间隙锁（Gap Lock）演示

```sql
-- === 窗口A ===
START TRANSACTION;

-- 查询不存在的记录（加间隙锁，锁住(5, 10)区间）
SELECT * FROM lock_test WHERE id = 7 FOR UPDATE;

-- 等待窗口B...
```

```sql
-- === 窗口B ===
START TRANSACTION;

-- 插入间隙内的数据（被阻塞）
INSERT INTO lock_test VALUES (6, 'x', 25);
-- 阻塞！

-- 插入间隙外的数据（不阻塞）
INSERT INTO lock_test VALUES (11, 'y', 35);
-- 成功！
```

```sql
-- === 窗口A ===
COMMIT;

-- 窗口B的插入继续执行
```

#### 10. Next-Key Lock演示

```sql
-- === 窗口A ===
START TRANSACTION;

-- 范围查询（加Next-Key Lock）
SELECT * FROM lock_test WHERE id >= 5 AND id < 10 FOR UPDATE;
-- 锁住：(1, 5]、(5, 10]

-- 等待窗口B...
```

```sql
-- === 窗口B ===
START TRANSACTION;

-- 插入被锁区间的数据
INSERT INTO lock_test VALUES (6, 'x', 25);
-- 阻塞！

INSERT INTO lock_test VALUES (3, 'y', 15);
-- 阻塞！

-- 插入未锁区间的数据
INSERT INTO lock_test VALUES (11, 'z', 35);
-- 成功！
```

#### 11. 两阶段锁协议演示

```sql
-- 事务中，锁在COMMIT时统一释放

START TRANSACTION;

-- 第1步：更新A（加锁）
UPDATE lock_test SET age = 11 WHERE id = 1;

-- 第2步：更新B（加锁）
UPDATE lock_test SET age = 21 WHERE id = 5;

-- 此时两个锁都未释放

COMMIT;
-- 统一释放所有锁

-- 优化建议：把最可能冲突的锁往后放
-- 例如：如果id=5冲突多，id=1冲突少，应该先更新id=1，后更新id=5
```

#### 12. 死锁演示

```sql
-- === 窗口A ===
START TRANSACTION;
UPDATE lock_test SET age = 11 WHERE id = 1;

-- 等待窗口B先执行...

-- 然后执行：
UPDATE lock_test SET age = 21 WHERE id = 5;
-- 死锁！MySQL会自动检测并回滚其中一个事务
```

```sql
-- === 窗口B ===
START TRANSACTION;
UPDATE lock_test SET age = 22 WHERE id = 5;

-- 然后执行：
UPDATE lock_test SET age = 12 WHERE id = 1;
-- 触发死锁检测
```

```sql
-- 查看死锁日志
SHOW ENGINE INNODB STATUS\G

-- 在LATEST DETECTED DEADLOCK部分可以看到死锁信息
```

### 第08讲实操：当前读 vs 快照读

#### 13. 快照读演示

```sql
-- === 窗口A ===
USE mysql_study;

START TRANSACTION;
-- 创建一致性视图

SELECT * FROM lock_test WHERE id = 5;
-- 结果：age = 20

-- 等待窗口B...

-- 再次查询（快照读）
SELECT * FROM lock_test WHERE id = 5;
-- 结果：age = 20（读取的是快照版本）

COMMIT;

-- 提交后查询
SELECT * FROM lock_test WHERE id = 5;
-- 结果：age = 25（读取最新版本）
```

```sql
-- === 窗口B ===
START TRANSACTION;
UPDATE lock_test SET age = 25 WHERE id = 5;
COMMIT;

-- 窗口A的快照读不受影响
```

#### 14. 当前读演示

```sql
-- === 窗口A ===
START TRANSACTION;

-- 当前读（读取最新版本，加锁）
SELECT * FROM lock_test WHERE id = 5 FOR UPDATE;
-- 结果：age = 25（读取最新版本）

-- 等待窗口B...
```

```sql
-- === 窗口B ===
START TRANSACTION;

-- 尝试更新（被阻塞）
UPDATE lock_test SET age = 30 WHERE id = 5;
-- 阻塞！因为窗口A持有排他锁
```

```sql
-- === 窗口A ===
COMMIT;

-- 窗口B的更新继续执行
```

#### 15. READ COMMITTED级别下的视图

```sql
-- === 窗口A ===
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

START TRANSACTION;
SELECT * FROM lock_test WHERE id = 5;
-- 结果：age = 30

-- 等待窗口B...

-- 再次查询（每次查询创建新视图）
SELECT * FROM lock_test WHERE id = 5;
-- 结果：age = 35（读取到了其他事务的提交）

COMMIT;
```

```sql
-- === 窗口B ===
START TRANSACTION;
UPDATE lock_test SET age = 35 WHERE id = 5;
COMMIT;

-- 窗口A的查询会读到新值
```

---

## 重点总结

### 锁的分类

1. **全局锁（FTWRL）**：
   - 全库只读
   - 用于备份（不推荐）
   - 推荐：--single-transaction

2. **表级锁**：
   - 表锁：LOCK TABLES（很少用）
   - MDL锁：自动加锁，保护表结构

3. **行锁**（InnoDB）：
   - 记录锁：锁住索引记录
   - 间隙锁：锁住间隙，防止幻读
   - Next-Key Lock：记录锁+间隙锁

### 关键知识点

1. **MDL锁问题**：
   - 长事务持有MDL读锁
   - DDL被阻塞
   - 后续DML也被阻塞

2. **两阶段锁协议**：
   - 锁在COMMIT时统一释放
   - 优化：把冲突锁往后放

3. **当前读 vs 快照读**：
   - 快照读：MVCC，不加锁
   - 当前读：读最新版本，加锁

4. **死锁**：
   - 两个事务相互等待
   - MySQL自动检测并回滚其中一个

---

## 课后思考

1. 为什么不推荐使用FTWRL进行备份？
   - 提示：业务影响、替代方案

2. 如何避免MDL锁导致的数据库hang住？
   - 提示：长事务、DDL超时设置

3. 为什么InnoDB在REPEATABLE READ级别需要间隙锁？
   - 提示：幻读

4. 如何减少死锁的发生？
   - 提示：访问顺序、事务大小

---

## 下一步

完成本讲后，继续学习：
- **05-索引与性能优化.md**：索引选择、count优化、性能调优

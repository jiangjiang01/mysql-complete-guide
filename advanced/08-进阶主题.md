# 08-进阶主题

> 对应课程：第31-45讲（误删数据、JOIN、临时表、分区表等进阶内容）
> 学习时间：4-5小时
> 前置要求：已完成07-高可用架构学习

---

## 说明

本章涵盖第31-45讲的进阶主题，内容较多且相对独立。建议根据实际工作需求，选择性深入学习对应的PDF课程，并参考下面的核心知识点和实操示例。

---

## 第31讲：误删数据恢复

### 核心知识点

**误删场景**：
1. DELETE误删行
2. DROP TABLE/DATABASE
3. rm删除数据文件

**恢复方案**：
1. **flashback**：基于binlog回滚（需要工具支持）
2. **全量备份+binlog恢复**：
   - 恢复最近的全量备份
   - 应用binlog到误删前的时间点
3. **延迟复制从库**：
   - 配置从库延迟N小时
   - 从延迟从库恢复数据

### 实操练习

```sql
-- 场景1：误删行数据

-- 开启binlog（ROW格式）
SHOW VARIABLES LIKE 'binlog_format';

-- 模拟误删除
USE mysql_study;
DELETE FROM users WHERE id BETWEEN 100 AND 200;

-- 恢复方案：使用binlog2sql工具（第三方工具）
-- 1. 找到删除操作的binlog位置
SHOW BINLOG EVENTS IN 'binlog.000001';

-- 2. 使用binlog2sql生成反向SQL
-- binlog2sql --flashback -h127.0.0.1 -P3306 -uroot -p123456 \
--   --start-file='binlog.000001' --start-position=1000 --stop-position=2000 \
--   > rollback.sql

-- 3. 执行反向SQL恢复数据
-- mysql -uroot -p < rollback.sql

-- 场景2：误DROP TABLE

-- 模拟误删表
DROP TABLE users;

-- 恢复方案：全量备份+binlog
-- 1. 恢复最近的全量备份到临时库
-- mysql -uroot -p temp_db < backup.sql

-- 2. 应用binlog到DROP前
-- mysqlbinlog --start-datetime="2024-01-01 00:00:00" \
--   --stop-datetime="2024-01-15 10:00:00" \
--   binlog.000001 | mysql -uroot -p temp_db

-- 3. 从临时库导出数据
-- mysqldump -uroot -p temp_db users > users.sql

-- 4. 导入到生产库
-- mysql -uroot -p mysql_study < users.sql

-- 预防措施：
-- 1. 使用权限控制（限制DROP权限）
-- 2. SQL审核工具
-- 3. 定期备份
-- 4. 配置延迟从库

-- 配置延迟从库（延迟1小时）
STOP SLAVE;
CHANGE MASTER TO MASTER_DELAY = 3600;
START SLAVE;

-- 查看延迟配置
SHOW SLAVE STATUS\G
-- SQL_Delay: 3600
-- SQL_Remaining_Delay: 剩余延迟秒数
```

---

## 第32-33讲：KILL语句、内存管理

### 核心知识点

**第32讲：KILL不掉的语句**
- 大事务回滚：耗时长
- 大查询取消：清理临时文件耗时
- DDL KILL：等待MDL锁

**第33讲：大查询内存管理**
- 结果集发送机制：边读边发
- 不会占满内存
- 客户端缓存需注意

### 实操练习

```sql
-- 场景1：KILL大事务

-- 模拟大事务
START TRANSACTION;
UPDATE large_table SET col = col + 1;  -- 100万行

-- 另一个窗口KILL
SHOW PROCESSLIST;
KILL <id>;

-- 观察回滚进度
SHOW ENGINE INNODB STATUS\G
-- 查看TRANSACTIONS部分

-- 场景2：大查询内存

-- 查询大结果集
SELECT * FROM large_table;  -- 100万行

-- MySQL server端不会占用100万行的内存
-- 采用流式发送（net_buffer_length）

SHOW VARIABLES LIKE 'net_buffer_length';

-- 注意：客户端可能缓存全部结果
-- 使用流式查询（应用层）
-- 例如Python: cursor.execute(sql, cursor=True)
```

---

## 第34-35讲：JOIN优化

### 核心知识点

**JOIN算法**：
1. **Index Nested-Loop Join（NLJ）**：
   - 被驱动表有索引
   - 性能最好

2. **Block Nested-Loop Join（BNL）**：
   - 被驱动表无索引
   - 使用join buffer
   - 性能较差

3. **Hash Join（MySQL 8.0.18+）**：
   - 替代BNL
   - 性能更好

**优化建议**：
1. 小表驱动大表
2. 被驱动表加索引
3. 使用覆盖索引

### 实操练习

```sql
USE mysql_study;

-- 创建测试表
CREATE TABLE t1 (
    id INT PRIMARY KEY,
    a INT,
    KEY idx_a (a)
) ENGINE=InnoDB;

CREATE TABLE t2 (
    id INT PRIMARY KEY,
    a INT
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO t1 SELECT n, n FROM
    (SELECT @n := @n + 1 AS n FROM
        (SELECT 1 UNION SELECT 2 UNION SELECT 3) ta,
        (SELECT 1 UNION SELECT 2 UNION SELECT 3) tb,
        (SELECT 1 UNION SELECT 2 UNION SELECT 3) tc,
        (SELECT @n := 0) init
    ) nums
LIMIT 100;

INSERT INTO t2 SELECT n, n FROM
    (SELECT @n := @n + 1 AS n FROM
        (SELECT 1 UNION SELECT 2 UNION SELECT 3) ta,
        (SELECT 1 UNION SELECT 2 UNION SELECT 3) tb,
        (SELECT 1 UNION SELECT 2 UNION SELECT 3) tc,
        (SELECT 1 UNION SELECT 2 UNION SELECT 3) td,
        (SELECT @n := 0) init
    ) nums
LIMIT 1000;

-- 场景1：NLJ（有索引）
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.a = t2.id;
-- Extra: Using index condition

-- 场景2：BNL（无索引，MySQL 5.7）
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.a = t2.a;
-- Extra: Using join buffer (Block Nested Loop)

-- MySQL 8.0使用Hash Join
-- Extra: Using hash join

-- 优化：为t2.a创建索引
CREATE INDEX idx_a ON t2(a);

EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.a = t2.a;
-- 变为NLJ，性能提升

-- 场景3：小表驱动大表
-- t1(100行) JOIN t2(1000行)

-- 方式1：t1驱动t2（推荐）
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.a = t2.a;

-- 方式2：t2驱动t1（不推荐）
EXPLAIN SELECT * FROM t2 JOIN t1 ON t1.a = t2.a;

-- 使用STRAIGHT_JOIN强制驱动顺序
EXPLAIN SELECT * FROM t1 STRAIGHT_JOIN t2 ON t1.a = t2.a;

-- 查看join buffer大小
SHOW VARIABLES LIKE 'join_buffer_size';

-- 增大join buffer（如果必须使用BNL）
SET SESSION join_buffer_size = 256 * 1024;  -- 256KB
```

---

## 第36-37讲：临时表

### 核心知识点

**第36讲：临时表可以重名**
- 会话级别：每个连接可创建同名临时表
- 自动删除：会话结束时删除
- 用途：复杂查询中间结果

**第37讲：内部临时表**
- GROUP BY、DISTINCT、UNION等触发
- 优先使用内存临时表
- 超过限制使用磁盘临时表

### 实操练习

```sql
-- 场景1：用户临时表

-- 连接A创建临时表
CREATE TEMPORARY TABLE temp_users (
    id INT,
    name VARCHAR(50)
);

INSERT INTO temp_users VALUES (1, 'Alice');

-- 连接B也可以创建同名临时表（不冲突）
CREATE TEMPORARY TABLE temp_users (
    id INT,
    name VARCHAR(50)
);

-- 查询（各自独立）
SELECT * FROM temp_users;

-- 场景2：内部临时表

-- 触发内部临时表：GROUP BY
EXPLAIN SELECT age, COUNT(*) FROM users GROUP BY age;
-- Extra: Using temporary

-- 查看临时表配置
SHOW VARIABLES LIKE 'tmp_table_size';        -- 内存临时表大小限制
SHOW VARIABLES LIKE 'max_heap_table_size';   -- MEMORY引擎限制

-- 监控临时表使用
SHOW GLOBAL STATUS LIKE 'Created_tmp%';
-- Created_tmp_tables: 内存临时表数
-- Created_tmp_disk_tables: 磁盘临时表数

-- 优化：避免磁盘临时表
-- 方式1：增大tmp_table_size
SET SESSION tmp_table_size = 32 * 1024 * 1024;  -- 32MB

-- 方式2：使用索引避免临时表
CREATE INDEX idx_age ON users(age);

EXPLAIN SELECT age, COUNT(*) FROM users GROUP BY age;
-- 可能不再使用临时表（取决于优化器）

-- 方式3：使用SQL_SMALL_RESULT提示
SELECT SQL_SMALL_RESULT age, COUNT(*) FROM users GROUP BY age;
-- 强制使用内存临时表
```

---

## 第38-40讲：存储引擎与自增ID

### 核心知识点

**第38讲：要不要用Memory引擎**
- 优点：快速
- 缺点：重启数据丢失、不支持TEXT/BLOB、锁粒度大
- 建议：用InnoDB + 大buffer pool替代

**第39讲：自增主键不连续**
- 原因：事务回滚、批量插入、AUTO_INCREMENT_INCREMENT
- 影响：一般无影响，除非业务依赖连续性

**第40讲：INSERT加锁**
- INSERT ... SELECT：锁源表
- 并发INSERT：自增锁
- 死锁风险

### 实操练习

```sql
-- 场景1：Memory引擎测试

CREATE TABLE mem_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data VARCHAR(100)
) ENGINE=MEMORY;

INSERT INTO mem_test (data) VALUES ('test1'), ('test2');

SELECT * FROM mem_test;

-- 重启MySQL后，数据丢失！

-- 建议：使用InnoDB替代
CREATE TABLE innodb_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data VARCHAR(100)
) ENGINE=InnoDB;

-- 场景2：自增ID不连续

CREATE TABLE auto_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50)
) ENGINE=InnoDB;

-- 插入
INSERT INTO auto_test (name) VALUES ('a');  -- id=1

-- 事务回滚
START TRANSACTION;
INSERT INTO auto_test (name) VALUES ('b');  -- id=2
ROLLBACK;

-- 再插入
INSERT INTO auto_test (name) VALUES ('c');  -- id=3（跳过了2）

SELECT * FROM auto_test;
-- id: 1, 3（不连续）

-- 查看当前自增值
SHOW CREATE TABLE auto_test;
-- AUTO_INCREMENT=4

-- 场景3：INSERT ... SELECT加锁

-- 源表
CREATE TABLE source (
    id INT PRIMARY KEY,
    data VARCHAR(100)
) ENGINE=InnoDB;

INSERT INTO source VALUES (1, 'a'), (2, 'b');

-- 目标表
CREATE TABLE target (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data VARCHAR(100)
) ENGINE=InnoDB;

-- INSERT ... SELECT会锁住source表
START TRANSACTION;
INSERT INTO target (data) SELECT data FROM source;

-- 另一个窗口尝试更新source
-- UPDATE source SET data = 'c' WHERE id = 1;
-- 阻塞！

COMMIT;

-- 解决：拆分为SELECT + INSERT
-- 或使用READ COMMITTED隔离级别
```

---

## 第41-43讲：表复制、权限、分区表

### 核心知识点

**第41讲：快速复制表**
- mysqldump
- CREATE TABLE ... LIKE + INSERT ... SELECT
- MySQL 8.0 Clone Plugin

**第42讲：grant后要flush privileges吗**
- 直接授权：不需要
- 修改系统表：需要（不推荐）

**第43讲：分区表**
- 优点：大表管理、历史数据归档
- 缺点：跨分区查询慢、主键限制
- 建议：谨慎使用

### 实操练习

```sql
-- 场景1：快速复制表

-- 方式1：CREATE TABLE ... LIKE
CREATE TABLE users_copy LIKE users;

INSERT INTO users_copy SELECT * FROM users;

-- 方式2：CREATE TABLE ... AS
CREATE TABLE users_copy2 AS SELECT * FROM users;

-- 注意：方式2不会复制索引

-- 方式3：mysqldump（命令行）
-- mysqldump -uroot -p mysql_study users | mysql -uroot -p mysql_study_copy

-- 场景2：权限管理

-- 创建用户并授权
CREATE USER 'test_user'@'localhost' IDENTIFIED BY 'password';

GRANT SELECT, INSERT ON mysql_study.* TO 'test_user'@'localhost';

-- 不需要FLUSH PRIVILEGES

-- 查看权限
SHOW GRANTS FOR 'test_user'@'localhost';

-- 回收权限
REVOKE INSERT ON mysql_study.* FROM 'test_user'@'localhost';

-- 场景3：分区表

-- 创建分区表（按日期范围分区）
CREATE TABLE orders_partitioned (
    id INT,
    order_date DATE,
    amount DECIMAL(10,2)
) ENGINE=InnoDB
PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 插入数据
INSERT INTO orders_partitioned VALUES
(1, '2022-01-01', 100),
(2, '2023-06-01', 200),
(3, '2024-01-01', 300);

-- 查看分区信息
SELECT
    PARTITION_NAME,
    TABLE_ROWS
FROM information_schema.PARTITIONS
WHERE TABLE_SCHEMA = 'mysql_study' AND TABLE_NAME = 'orders_partitioned';

-- 分区查询（自动路由）
EXPLAIN SELECT * FROM orders_partitioned WHERE order_date = '2023-06-01';
-- partitions: p2023

-- 删除历史分区
ALTER TABLE orders_partitioned DROP PARTITION p2022;

-- 添加新分区
ALTER TABLE orders_partitioned ADD PARTITION (
    PARTITION p2026 VALUES LESS THAN (2027)
);
```

---

## 第44-45讲：答疑与自增ID用完

### 核心知识点

**第44讲：好问题答疑**
- 综合知识点复习

**第45讲：自增ID用完怎么办**
- INT：42亿（2^31-1），用完报错
- BIGINT：92亿亿（2^63-1），几乎用不完
- 建议：使用BIGINT

### 实操练习

```sql
-- 场景1：自增ID上限测试

-- INT类型（最大21亿+）
CREATE TABLE int_test (
    id INT PRIMARY KEY AUTO_INCREMENT
) ENGINE=InnoDB;

-- 修改自增值到接近上限（测试）
ALTER TABLE int_test AUTO_INCREMENT = 2147483640;

-- 插入数据
INSERT INTO int_test VALUES ();  -- 成功
INSERT INTO int_test VALUES ();  -- 成功
-- ...继续插入直到达到上限
-- ERROR 1467: Failed to read auto-increment value from storage engine

-- 解决：迁移到BIGINT
CREATE TABLE bigint_test (
    id BIGINT PRIMARY KEY AUTO_INCREMENT
) ENGINE=InnoDB;

-- 迁移数据
INSERT INTO bigint_test SELECT * FROM int_test;

-- 场景2：UUID替代自增ID（适用于分布式）

CREATE TABLE uuid_test (
    id CHAR(36) PRIMARY KEY,
    data VARCHAR(100)
) ENGINE=InnoDB;

-- 插入
INSERT INTO uuid_test VALUES (UUID(), 'test');

SELECT * FROM uuid_test;

-- 注意：UUID作为主键的缺点
-- 1. 占用空间大（36字节 vs 8字节）
-- 2. 无序，影响插入性能（页分裂）
-- 3. 索引体积大

-- 优化：使用UUID_SHORT()（MySQL特有，基于server_id和时间戳）
SELECT UUID_SHORT();
-- 返回64位整数，可以作为BIGINT主键
```

---

## 学习建议

### 重要程度分级

**高优先级**（工作常用）：
- 第31讲：误删数据恢复
- 第34-35讲：JOIN优化
- 第37讲：内部临时表
- 第41讲：表复制

**中优先级**（了解即可）：
- 第32-33讲：KILL语句、内存管理
- 第36讲：临时表
- 第42讲：权限管理

**低优先级**（按需学习）：
- 第38讲：Memory引擎
- 第39-40讲：自增ID
- 第43讲：分区表
- 第45讲：自增ID用完

### 学习路径

1. **先学核心**：聚焦第31、34-35、37讲
2. **深入实践**：结合PDF详细学习
3. **查漏补缺**：根据工作需求补充其他章节
4. **持续总结**：记录问题和解决方案

---

## 重点总结

### 数据恢复

1. **预防措施**：
   - 定期全量备份
   - 开启binlog（ROW格式）
   - 配置延迟从库
   - 权限控制

2. **恢复方案**：
   - flashback（binlog回滚）
   - 全量备份+binlog恢复

### JOIN优化

3. **优化原则**：
   - 小表驱动大表
   - 被驱动表加索引
   - 避免BNL，优先NLJ

4. **Hash Join**（MySQL 8.0.18+）：
   - 替代BNL
   - 性能更好

### 临时表

5. **内部临时表**：
   - GROUP BY、DISTINCT触发
   - 优先内存，超限磁盘
   - 监控Created_tmp_disk_tables

6. **优化方向**：
   - 增大tmp_table_size
   - 使用索引避免临时表

---

## 课后思考

1. 误删数据后，如何快速恢复？有哪些预防措施？
2. JOIN查询如何优化？什么时候会使用BNL？
3. 什么情况下会使用内部临时表？如何避免磁盘临时表？
4. 分区表适用于什么场景？有哪些限制？

---

## 恭喜完成

完成本讲后，你已经学完了MySQL实战45讲的全部核心内容！

接下来建议：
1. 结合实际项目巩固所学
2. 深入阅读《高性能MySQL》
3. 搭建测试环境实践高可用架构
4. 持续关注MySQL新特性

**继续加油！** 🎉

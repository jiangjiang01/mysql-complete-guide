# 05-索引与性能优化

> 对应课程：第09-14讲（索引选择、性能调优、count优化）
> 学习时间：3-4小时
> 前置要求：已完成04-锁机制学习

---

## 核心知识点概览

### 本章内容

- **第09讲**：普通索引 vs 唯一索引
- **第10讲**：MySQL为什么会选错索引
- **第11讲**：字符串字段如何加索引
- **第12讲**：为什么MySQL会"抖"
- **第13讲**：表数据删除后空间不释放
- **第14讲**：count性能优化

---

## 第09讲：普通索引 vs 唯一索引

### 核心知识点

**change buffer（写缓冲）**：
- 适用于**普通索引**
- 更新时先写change buffer，不立即读磁盘
- 后台merge到数据页
- 减少随机IO

**唯一索引**：
- 需要判断唯一性
- 必须读取数据页
- 无法使用change buffer

**使用建议**：
- 写多读少：普通索引（利用change buffer）
- 写少读多：差别不大
- 不建议用唯一索引（除非业务强制要求）

### 实操练习

```sql
USE mysql_study;

-- 创建两张表对比
CREATE TABLE t_unique (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL UNIQUE,
    name VARCHAR(50),
    age INT
) ENGINE=InnoDB;

CREATE TABLE t_normal (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    name VARCHAR(50),
    age INT,
    KEY idx_user_id (user_id)
) ENGINE=InnoDB;

-- 查看change buffer配置
SHOW VARIABLES LIKE 'innodb_change_buffer_max_size';
-- 默认25，表示change buffer占buffer pool的25%

SHOW VARIABLES LIKE 'innodb_change_buffering';
-- all: 缓冲insert、delete、purge操作

-- 插入数据对比性能
-- 准备大量数据测试
DELIMITER $$
CREATE PROCEDURE insert_data(IN num INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i <= num DO
        INSERT INTO t_normal (user_id, name, age)
        VALUES (i, CONCAT('user', i), 20 + (i % 50));
        SET i = i + 1;
    END WHILE;
END$$
DELIMITER ;

-- 插入测试数据
CALL insert_data(10000);

-- 查看change buffer使用情况
SHOW ENGINE INNODB STATUS\G
-- 查看INSERT BUFFER AND ADAPTIVE HASH INDEX部分

-- 删除测试
DELETE FROM t_normal WHERE user_id BETWEEN 1000 AND 2000;

-- merge操作
-- 后台自动merge，也可以手动触发
-- 方式1：查询相关数据（触发merge）
SELECT * FROM t_normal WHERE user_id = 1500;

-- 方式2：关闭MySQL（触发完整merge）
-- shutdown

-- 结论：
-- 普通索引在大量写入时，性能优于唯一索引（得益于change buffer）
```

---

## 第10讲：MySQL为什么会选错索引

### 核心知识点

**优化器选择索引的依据**：
1. 扫描行数（主要依据）
2. 是否使用临时表
3. 是否排序

**扫描行数估算**：
- 通过索引的**区分度（cardinality）**估算
- cardinality通过采样统计，可能不准确

**索引选错的原因**：
- 统计信息不准确
- 数据分布不均匀
- 优化器误判

**解决方案**：
1. `ANALYZE TABLE` 重新统计索引信息
2. `FORCE INDEX` 强制使用索引
3. 修改SQL语句引导优化器
4. 删除误用的索引

### 实操练习

```sql
USE mysql_study;

-- 创建测试表
CREATE TABLE index_choice (
    id INT PRIMARY KEY AUTO_INCREMENT,
    a INT,
    b INT,
    KEY idx_a (a),
    KEY idx_b (b)
) ENGINE=InnoDB;

-- 插入测试数据（构造数据分布不均匀的场景）
INSERT INTO index_choice (a, b)
SELECT
    FLOOR(1 + RAND() * 10),  -- a列：1-10
    FLOOR(1 + RAND() * 10000) -- b列：1-10000
FROM
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t1,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t2,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t3,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t4,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t5;

-- 查看索引统计信息
SHOW INDEX FROM index_choice;
-- 关注CARDINALITY列

-- 查看执行计划
EXPLAIN SELECT * FROM index_choice WHERE a BETWEEN 1 AND 5 AND b > 5000;
-- 观察key列，看MySQL选择了哪个索引

-- 如果MySQL选错索引，可以：

-- 方案1：重新统计索引信息
ANALYZE TABLE index_choice;

-- 再次查看执行计划
EXPLAIN SELECT * FROM index_choice WHERE a BETWEEN 1 AND 5 AND b > 5000;

-- 方案2：强制使用索引
EXPLAIN SELECT * FROM index_choice FORCE INDEX(idx_b)
WHERE a BETWEEN 1 AND 5 AND b > 5000;

-- 方案3：引导优化器（增加order by）
EXPLAIN SELECT * FROM index_choice
WHERE a BETWEEN 1 AND 5 AND b > 5000
ORDER BY b;
-- 优化器可能选择idx_b避免排序

-- 查看优化器trace（详细分析）
SET optimizer_trace='enabled=on';

SELECT * FROM index_choice WHERE a BETWEEN 1 AND 5 AND b > 5000;

SELECT * FROM information_schema.OPTIMIZER_TRACE\G

SET optimizer_trace='enabled=off';

-- 查看索引使用统计（MySQL 8.0+）
SELECT
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_STAR,
    COUNT_READ,
    COUNT_FETCH
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'mysql_study' AND OBJECT_NAME = 'index_choice';
```

---

## 第11讲：字符串字段如何加索引

### 核心知识点

**字符串索引方案对比**：

1. **完整索引**：
   - 占用空间大
   - 查询性能好

2. **前缀索引**：
   - 占用空间小
   - 可能需要回表验证
   - 不能用于覆盖索引
   - 不能用于ORDER BY

3. **倒序存储 + 前缀索引**：
   - 适合前缀区分度低的场景（如身份证号）

4. **hash字段索引**：
   - 额外存储hash值
   - 只能等值查询
   - 不能范围查询

**前缀长度选择**：
```sql
-- 计算不同前缀长度的区分度
SELECT
    COUNT(DISTINCT LEFT(email, 4)) / COUNT(*) AS prefix_4,
    COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) AS prefix_5,
    COUNT(DISTINCT LEFT(email, 6)) / COUNT(*) AS prefix_6,
    COUNT(DISTINCT LEFT(email, 7)) / COUNT(*) AS prefix_7,
    COUNT(DISTINCT email) / COUNT(*) AS full
FROM users;

-- 选择区分度接近完整字段的最短前缀
```

### 实操练习

```sql
USE mysql_study;

-- 创建测试表
CREATE TABLE user_info (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100),
    id_card CHAR(18),
    phone CHAR(11)
) ENGINE=InnoDB;

-- 插入测试数据
INSERT INTO user_info (email, id_card, phone)
SELECT
    CONCAT('user', n, '@example.com'),
    CONCAT('11010119900101', LPAD(n, 4, '0')),
    CONCAT('138', LPAD(n, 8, '0'))
FROM
    (SELECT @n := @n + 1 AS n FROM
        (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t1,
        (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t2,
        (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t3,
        (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t4,
        (SELECT @n := 0) init
    ) nums
LIMIT 10000;

-- 方案1：完整索引
CREATE INDEX idx_email_full ON user_info(email);

EXPLAIN SELECT * FROM user_info WHERE email = 'user1000@example.com';
-- key_len: 403（VARCHAR(100) * 4 + 2 + 1，utf8mb4）

-- 方案2：前缀索引
-- 先分析前缀长度
SELECT
    COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) AS prefix_5,
    COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) AS prefix_10,
    COUNT(DISTINCT LEFT(email, 15)) / COUNT(*) AS prefix_15,
    COUNT(DISTINCT email) / COUNT(*) AS full
FROM user_info;

-- 创建前缀索引（假设选择10）
CREATE INDEX idx_email_prefix ON user_info(email(10));

EXPLAIN SELECT * FROM user_info WHERE email = 'user1000@example.com';
-- key_len: 43（VARCHAR(10) * 4 + 2 + 1）

-- 注意：前缀索引不能用于覆盖索引
EXPLAIN SELECT id, email FROM user_info WHERE email = 'user1000@example.com';
-- Extra: Using index condition（需要回表验证完整email）

-- 方案3：倒序存储（适合身份证号场景）
ALTER TABLE user_info ADD COLUMN id_card_reverse CHAR(18);

UPDATE user_info SET id_card_reverse = REVERSE(id_card);

CREATE INDEX idx_id_card_reverse ON user_info(id_card_reverse(6));

-- 查询时倒序
SELECT * FROM user_info WHERE id_card_reverse = REVERSE('110101199001010001');

-- 方案4：hash字段
ALTER TABLE user_info ADD COLUMN email_hash INT UNSIGNED;

UPDATE user_info SET email_hash = CRC32(email);

CREATE INDEX idx_email_hash ON user_info(email_hash);

-- 查询时使用hash
EXPLAIN SELECT * FROM user_info
WHERE email_hash = CRC32('user1000@example.com')
  AND email = 'user1000@example.com';
-- 注意：要同时判断email，避免hash冲突

-- 对比索引大小
SELECT
    INDEX_NAME,
    ROUND(STAT_VALUE * @@innodb_page_size / 1024 / 1024, 2) AS size_mb
FROM mysql.innodb_index_stats
WHERE TABLE_NAME = 'user_info' AND DATABASE_NAME = 'mysql_study'
  AND INDEX_NAME LIKE 'idx_email%';
```

---

## 第12讲：MySQL为什么会"抖"

### 核心知识点

**MySQL"抖动"原因**：
- **脏页刷盘（flush）**：redo log写满 或 内存不够

**脏页**：内存中被修改但未写入磁盘的数据页

**刷脏页时机**：
1. redo log满了（系统停止更新）
2. 内存不够（淘汰脏页）
3. 系统空闲（后台刷）
4. MySQL正常关闭

**优化参数**：
```sql
-- 控制刷脏页速度
innodb_io_capacity = 20000  -- 根据磁盘IOPS设置

-- 脏页比例
innodb_max_dirty_pages_pct = 75  -- 脏页超过75%触发刷脏页

-- 后台刷脏线程数
innodb_page_cleaners = 4
```

### 实操练习

```sql
-- 查看当前脏页比例
SELECT
    VARIABLE_VALUE AS dirty_pages
FROM performance_schema.global_status
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';

SELECT
    VARIABLE_VALUE AS total_pages
FROM performance_schema.global_status
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';

-- 计算脏页比例
SELECT
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2
    ) AS dirty_pages_pct;

-- 查看刷脏页相关配置
SHOW VARIABLES LIKE 'innodb_io_capacity%';
SHOW VARIABLES LIKE 'innodb_max_dirty_pages_pct%';
SHOW VARIABLES LIKE 'innodb_page_cleaners';

-- 查看redo log配置
SHOW VARIABLES LIKE 'innodb_log_file_size';
SHOW VARIABLES LIKE 'innodb_log_files_in_group';

-- 监控刷脏页活动
SHOW ENGINE INNODB STATUS\G
-- 查看LOG部分和BUFFER POOL AND MEMORY部分

-- 模拟大量写入，观察脏页变化
CREATE TABLE flush_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data VARCHAR(1000)
) ENGINE=InnoDB;

-- 大量插入
INSERT INTO flush_test (data)
SELECT REPEAT('x', 1000)
FROM
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t1,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t2,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t3,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t4,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t5;

-- 再次查看脏页比例
-- 观察是否增加

-- 优化建议：
-- 1. 设置合理的innodb_io_capacity（根据磁盘性能）
-- 2. 增大redo log大小（减少写满频率）
-- 3. 增大buffer pool大小（减少内存不足）
```

---

## 第13讲：表数据删除后空间不释放

### 核心知识点

**数据删除后空间不释放的原因**：
- InnoDB数据页标记删除，不实际回收
- 产生**空洞（fragmentation）**

**回收空间方法**：
```sql
-- 方法1：重建表
ALTER TABLE t ENGINE=InnoDB;

-- 方法2：OPTIMIZE TABLE（等同于方法1）
OPTIMIZE TABLE t;

-- MySQL 5.6+使用Online DDL，不阻塞DML
```

**重建表过程（Online DDL）**：
1. 建立临时表
2. 扫描主表数据写入临时表
3. 增量日志记录DML操作
4. 应用增量日志
5. 替换表

### 实操练习

```sql
USE mysql_study;

-- 创建测试表
CREATE TABLE space_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data VARCHAR(1000)
) ENGINE=InnoDB;

-- 插入100000条数据
INSERT INTO space_test (data)
SELECT REPEAT('x', 1000)
FROM
    (SELECT 1 UNION SELECT 2) t1,
    (SELECT 1 UNION SELECT 2) t2,
    (SELECT 1 UNION SELECT 2) t3,
    (SELECT 1 UNION SELECT 2) t4,
    (SELECT 1 UNION SELECT 2) t5,
    (SELECT 1 UNION SELECT 2) t6,
    (SELECT 1 UNION SELECT 2) t7,
    (SELECT 1 UNION SELECT 2) t8,
    (SELECT 1 UNION SELECT 2) t9,
    (SELECT 1 UNION SELECT 2) t10,
    (SELECT 1 UNION SELECT 2) t11,
    (SELECT 1 UNION SELECT 2) t12,
    (SELECT 1 UNION SELECT 2) t13,
    (SELECT 1 UNION SELECT 2) t14,
    (SELECT 1 UNION SELECT 2) t15,
    (SELECT 1 UNION SELECT 2) t16;

-- 查看表大小
SELECT
    TABLE_NAME,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS size_mb,
    ROUND(DATA_FREE / 1024 / 1024, 2) AS free_mb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mysql_study' AND TABLE_NAME = 'space_test';

-- 删除一半数据
DELETE FROM space_test WHERE id % 2 = 0;

-- 再次查看表大小
SELECT
    TABLE_NAME,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS size_mb,
    ROUND(DATA_FREE / 1024 / 1024, 2) AS free_mb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mysql_study' AND TABLE_NAME = 'space_test';
-- 发现size_mb没有减小，DATA_FREE增加（空洞）

-- 回收空间：重建表
ALTER TABLE space_test ENGINE=InnoDB;

-- 查看表大小（空间回收）
SELECT
    TABLE_NAME,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS size_mb,
    ROUND(DATA_FREE / 1024 / 1024, 2) AS free_mb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mysql_study' AND TABLE_NAME = 'space_test';

-- 或使用OPTIMIZE TABLE
OPTIMIZE TABLE space_test;

-- 注意事项：
-- 1. 重建表会占用额外空间（临时表）
-- 2. 大表重建耗时较长
-- 3. 定期重建可以提升查询性能（减少碎片）
```

---

## 第14讲：count性能优化

### 核心知识点

**count(*)性能问题**：
- InnoDB需要扫描全表（MVCC原因，不同事务看到的行数不同）
- MyISAM直接返回（表级计数器）

**count函数对比**：
- `count(*)`：统计总行数（推荐）
- `count(1)`：统计总行数（同count(*)）
- `count(主键)`：遍历主键索引
- `count(字段)`：统计字段非NULL行数

**性能排序**：
```
count(*) ≈ count(1) > count(主键) > count(字段)
```

**优化方案**：
1. 使用覆盖索引（最小的二级索引）
2. 缓存计数（Redis）
3. 单独计数表

### 实操练习

```sql
USE mysql_study;

-- 使用之前创建的users表（10000条数据）

-- 方案1：count(*)，MySQL会选择最小的索引
EXPLAIN SELECT COUNT(*) FROM users;
-- possible_keys: idx_name, idx_age等
-- key: 选择最小的索引

-- 执行并记录时间
SELECT COUNT(*) FROM users;

-- 方案2：count(1)，性能相同
SELECT COUNT(1) FROM users;

-- 方案3：count(主键)
SELECT COUNT(id) FROM users;

-- 方案4：count(字段)，最慢（需要判断NULL）
SELECT COUNT(email) FROM users;

-- 性能对比（大表差异明显）
-- 创建大表测试
CREATE TABLE count_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    a INT,
    b VARCHAR(100),
    KEY idx_a (a)
) ENGINE=InnoDB;

-- 插入大量数据（根据机器性能调整数量）
INSERT INTO count_test (a, b)
SELECT
    FLOOR(1 + RAND() * 100),
    REPEAT('x', 50)
FROM users, (SELECT 1 UNION SELECT 2 UNION SELECT 3) t;
-- 30000条数据

-- 对比不同count方式
SELECT COUNT(*) FROM count_test;
SELECT COUNT(1) FROM count_test;
SELECT COUNT(id) FROM count_test;
SELECT COUNT(a) FROM count_test;

-- 优化1：使用覆盖索引
-- MySQL自动选择最小的二级索引
EXPLAIN SELECT COUNT(*) FROM count_test;

-- 优化2：近似值（EXPLAIN估算）
EXPLAIN SELECT * FROM count_test;
-- rows列是估算值，可用于快速获取近似总数

SELECT TABLE_ROWS
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mysql_study' AND TABLE_NAME = 'count_test';
-- 返回近似值

-- 优化3：单独计数表
CREATE TABLE count_cache (
    table_name VARCHAR(50) PRIMARY KEY,
    row_count INT
) ENGINE=InnoDB;

-- 初始化
INSERT INTO count_cache VALUES ('count_test', (SELECT COUNT(*) FROM count_test));

-- 插入数据时更新计数
START TRANSACTION;
INSERT INTO count_test (a, b) VALUES (10, 'test');
UPDATE count_cache SET row_count = row_count + 1 WHERE table_name = 'count_test';
COMMIT;

-- 删除数据时更新计数
START TRANSACTION;
DELETE FROM count_test WHERE id = 1;
UPDATE count_cache SET row_count = row_count - 1 WHERE table_name = 'count_test';
COMMIT;

-- 查询总数（快速）
SELECT row_count FROM count_cache WHERE table_name = 'count_test';

-- 注意：使用事务保证一致性
```

---

## 重点总结

### 索引选择

1. **普通索引 vs 唯一索引**：
   - 写多读少：普通索引（change buffer）
   - 业务无强制要求：优先普通索引

2. **索引选错解决**：
   - ANALYZE TABLE
   - FORCE INDEX
   - 修改SQL引导优化器

3. **字符串索引**：
   - 完整索引 vs 前缀索引
   - 倒序存储（身份证号场景）
   - hash字段（等值查询场景）

### 性能优化

4. **MySQL"抖动"**：
   - 原因：刷脏页
   - 优化：调整innodb_io_capacity、增大redo log

5. **空间回收**：
   - 删除数据产生空洞
   - ALTER TABLE ENGINE=InnoDB或OPTIMIZE TABLE回收

6. **count优化**：
   - count(*) ≈ count(1) > count(主键) > count(字段)
   - 使用覆盖索引
   - 缓存计数（Redis或单独计数表）

---

## 课后思考

1. 为什么普通索引能使用change buffer，而唯一索引不能？
2. 什么情况下MySQL会选错索引？如何解决？
3. 前缀索引有哪些限制？如何选择合适的前缀长度？
4. 为什么InnoDB的count(*)需要扫描全表？
5. 如何在业务中实现高效的计数功能？

---

## 下一步

完成本讲后，继续学习：
- **06-查询优化.md**：ORDER BY、JOIN、临时表等查询优化

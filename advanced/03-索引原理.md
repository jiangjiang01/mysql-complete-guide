# 03-索引原理

> 对应课程：第04-05讲（深入浅出索引上/下）
> 学习时间：2-3小时
> 前置要求：已完成02-事务隔离学习

---

## 核心知识点

### 索引的作用

索引是数据库中用于**提高数据检索效率**的数据结构，类似于书籍的目录。

**没有索引**：全表扫描，时间复杂度O(N)
**有索引**：快速定位，时间复杂度O(log N)

### 常见索引模型

1. **哈希表**：适合等值查询，不支持范围查询
2. **有序数组**：查询快，但插入/删除慢，适合静态数据
3. **B+树**：**InnoDB使用**，查询和更新都高效

### InnoDB的B+树索引

**B+树特点**：
- 所有数据存储在叶子节点
- 叶子节点之间通过双向链表连接
- 非叶子节点只存储索引键
- 每个节点对应一个数据页（默认16KB）

**索引类型**：

1. **主键索引（聚簇索引）**
   - 叶子节点存储**完整的行数据**
   - 每张InnoDB表有且只有一个主键索引

2. **普通索引（二级索引/辅助索引）**
   - 叶子节点存储**主键值**
   - 需要**回表**查询完整数据

**回表**：通过普通索引找到主键值后，再通过主键索引查询完整数据。

**覆盖索引**：查询的列都在索引中，无需回表。

### 索引维护

**页分裂**：插入数据导致页满，需要分裂成两个页，影响性能。
**页合并**：删除数据导致页利用率低，合并相邻页。

**主键选择建议**：
- 推荐：自增主键（减少页分裂，节省空间）
- 避免：业务主键（如身份证号），除非业务有唯一索引需求

---

## 实操练习

### 第04讲：索引基础

#### 1. 创建测试表（主键索引 vs 普通索引）

```sql
USE mysql_study;

-- 创建用户表（自增主键）
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    age INT,
    email VARCHAR(100)
) ENGINE=InnoDB;

-- 插入测试数据（100万条，实际测试可减少数量）
-- 使用存储过程批量插入
DELIMITER $$
CREATE PROCEDURE insert_users(IN num INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i <= num DO
        INSERT INTO users (name, age, email) VALUES
        (CONCAT('user', i), 20 + (i % 50), CONCAT('user', i, '@example.com'));
        SET i = i + 1;
    END WHILE;
END$$
DELIMITER ;

-- 插入10000条测试数据
CALL insert_users(10000);

-- 查看表数据量
SELECT COUNT(*) FROM users;
```

#### 2. 查看索引结构

```sql
-- 查看表的索引
SHOW INDEX FROM users;

-- 查看表结构
SHOW CREATE TABLE users\G

-- 查看索引统计信息
SELECT
    INDEX_NAME,
    CARDINALITY,
    INDEX_TYPE
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'mysql_study' AND TABLE_NAME = 'users';
```

#### 3. 演示主键索引查询

```sql
-- 通过主键查询（走主键索引）
EXPLAIN SELECT * FROM users WHERE id = 1000;
-- key: PRIMARY
-- type: const（最优）
-- rows: 1

-- 查看实际执行情况
SELECT * FROM users WHERE id = 1000;
```

#### 4. 演示普通索引查询（无索引）

```sql
-- 通过name查询（无索引，全表扫描）
EXPLAIN SELECT * FROM users WHERE name = 'user1000';
-- key: NULL
-- type: ALL（全表扫描）
-- rows: 约10000

-- 查看执行时间
SELECT * FROM users WHERE name = 'user1000';
```

#### 5. 创建普通索引

```sql
-- 在name字段创建索引
CREATE INDEX idx_name ON users(name);

-- 再次查询
EXPLAIN SELECT * FROM users WHERE name = 'user1000';
-- key: idx_name
-- type: ref
-- rows: 1

-- 性能提升明显！
SELECT * FROM users WHERE name = 'user1000';
```

#### 6. 演示回表过程

```sql
-- 查询所有字段（需要回表）
EXPLAIN SELECT * FROM users WHERE name = 'user1000';
-- Extra: Using index condition

-- 实际执行流程：
-- 1. 通过idx_name找到主键id
-- 2. 通过主键索引回表查询完整数据

SELECT * FROM users WHERE name = 'user1000';
```

#### 7. 演示覆盖索引（无需回表）

```sql
-- 只查询name和id（覆盖索引）
EXPLAIN SELECT id, name FROM users WHERE name = 'user1000';
-- Extra: Using index（覆盖索引，无需回表）

-- 性能更优！
SELECT id, name FROM users WHERE name = 'user1000';

-- 对比：查询所有字段
EXPLAIN SELECT * FROM users WHERE name = 'user1000';
-- Extra: NULL（需要回表）
```

### 第05讲：索引优化

#### 8. 联合索引（最左前缀原则）

```sql
-- 创建联合索引
CREATE INDEX idx_name_age ON users(name, age);

-- 可以使用索引的情况：

-- 1. 使用name（最左前缀）
EXPLAIN SELECT * FROM users WHERE name = 'user1000';
-- key: idx_name_age

-- 2. 使用name和age
EXPLAIN SELECT * FROM users WHERE name = 'user1000' AND age = 25;
-- key: idx_name_age

-- 3. 只使用age（不能使用索引）
EXPLAIN SELECT * FROM users WHERE age = 25;
-- key: NULL（全表扫描）

-- 最左前缀原则：必须从索引的最左列开始，并且不能跳过中间列
```

#### 9. 索引下推（Index Condition Pushdown, ICP）

```sql
-- MySQL 5.6+支持索引下推

-- 查询name和age
EXPLAIN SELECT * FROM users
WHERE name LIKE 'user100%' AND age = 25;
-- Extra: Using index condition（索引下推）

-- 索引下推的作用：
-- 1. 在索引遍历过程中，先过滤age条件
-- 2. 减少回表次数，提升性能

SELECT * FROM users
WHERE name LIKE 'user100%' AND age = 25;
```

#### 10. 前缀索引

```sql
-- 为email创建前缀索引（只索引前10个字符）
CREATE INDEX idx_email_prefix ON users(email(10));

-- 查看索引
SHOW INDEX FROM users WHERE KEY_NAME = 'idx_email_prefix';

-- 使用前缀索引查询
EXPLAIN SELECT * FROM users WHERE email = 'user1000@example.com';
-- key: idx_email_prefix

-- 注意：前缀索引不能做覆盖索引
EXPLAIN SELECT email FROM users WHERE email = 'user1000@example.com';
-- Extra: Using index condition（需要回表验证完整email）
```

#### 11. 主键选择：自增 vs 业务主键

```sql
-- 创建使用业务主键的表（身份证号）
CREATE TABLE users_with_business_pk (
    id_card CHAR(18) PRIMARY KEY,  -- 身份证号作为主键
    name VARCHAR(50),
    age INT
) ENGINE=InnoDB;

-- 插入数据（模拟乱序插入）
INSERT INTO users_with_business_pk VALUES
('110101199001011234', '张三', 25),
('110101199002021235', '李四', 24),
('110101198912011236', '王五', 26);  -- 插入位置在中间，可能导致页分裂

-- 对比：自增主键表
CREATE TABLE users_with_auto_pk (
    id INT PRIMARY KEY AUTO_INCREMENT,
    id_card CHAR(18),
    name VARCHAR(50),
    age INT,
    UNIQUE KEY uk_id_card (id_card)  -- 身份证号作为唯一索引
) ENGINE=InnoDB;

-- 插入相同数据（自增主键，顺序插入，无页分裂）
INSERT INTO users_with_auto_pk (id_card, name, age) VALUES
('110101199001011234', '张三', 25),
('110101199002021235', '李四', 24),
('110101198912011236', '王五', 26);

-- 建议：使用自增主键 + 业务字段唯一索引
```

#### 12. 分析索引使用情况

```sql
-- 查看表的索引大小
SELECT
    TABLE_NAME,
    INDEX_NAME,
    ROUND(STAT_VALUE * @@innodb_page_size / 1024 / 1024, 2) AS size_mb
FROM mysql.innodb_index_stats
WHERE TABLE_NAME = 'users' AND DATABASE_NAME = 'mysql_study';

-- 查看未使用的索引（MySQL 8.0+）
SELECT
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE INDEX_NAME IS NOT NULL
  AND COUNT_STAR = 0
  AND OBJECT_SCHEMA = 'mysql_study';
```

#### 13. 索引失效场景

```sql
-- 1. 使用函数导致索引失效
EXPLAIN SELECT * FROM users WHERE UPPER(name) = 'USER1000';
-- key: NULL（索引失效）

-- 正确写法：
EXPLAIN SELECT * FROM users WHERE name = 'user1000';
-- key: idx_name

-- 2. 类型转换导致索引失效
-- 假设email是VARCHAR类型
EXPLAIN SELECT * FROM users WHERE email = 123;
-- key: NULL（发生隐式类型转换）

-- 正确写法：
EXPLAIN SELECT * FROM users WHERE email = '123';

-- 3. LIKE以%开头导致索引失效
EXPLAIN SELECT * FROM users WHERE name LIKE '%1000';
-- key: NULL（索引失效）

-- 可以使用索引：
EXPLAIN SELECT * FROM users WHERE name LIKE 'user%';
-- key: idx_name

-- 4. OR条件中有未建索引的列
EXPLAIN SELECT * FROM users WHERE name = 'user1000' OR age = 25;
-- 如果age没有单独索引，可能不走idx_name_age
```

#### 14. 索引选择性

```sql
-- 索引选择性 = 不重复的索引值 / 总行数
-- 选择性越高，索引效果越好

-- 查看name的选择性
SELECT
    COUNT(DISTINCT name) / COUNT(*) AS selectivity
FROM users;
-- 结果：接近1，选择性很高，适合建索引

-- 查看age的选择性
SELECT
    COUNT(DISTINCT age) / COUNT(*) AS selectivity
FROM users;
-- 结果：较低（只有50个不同值），单独建索引效果一般

-- 建议：选择性高的列适合单独建索引，选择性低的列适合作为联合索引的一部分
```

#### 15. 强制使用索引

```sql
-- 有时MySQL可能选错索引，可以使用FORCE INDEX强制使用指定索引

-- 查看可用索引
SHOW INDEX FROM users;

-- 强制使用idx_name索引
EXPLAIN SELECT * FROM users FORCE INDEX(idx_name) WHERE name = 'user1000';

-- 忽略某个索引
EXPLAIN SELECT * FROM users IGNORE INDEX(idx_name) WHERE name = 'user1000';

-- 建议使用某个索引（MySQL可能不听）
EXPLAIN SELECT * FROM users USE INDEX(idx_name) WHERE name = 'user1000';
```

---

## 重点总结

### 索引类型

1. **主键索引（聚簇索引）**：
   - 叶子节点存储完整行数据
   - 推荐使用自增主键

2. **普通索引（二级索引）**：
   - 叶子节点存储主键值
   - 查询需要回表

3. **覆盖索引**：
   - 查询列都在索引中
   - 无需回表，性能最优

### 索引优化原则

1. **最左前缀原则**：联合索引必须从最左列开始使用

2. **索引选择性**：选择性高的列适合建索引

3. **避免索引失效**：
   - 不要在索引列上使用函数
   - 避免隐式类型转换
   - LIKE不要以%开头
   - OR条件注意索引使用

4. **主键选择**：
   - 优先使用自增主键
   - 业务字段可作为唯一索引

5. **前缀索引**：
   - 适合长字符串字段
   - 不能做覆盖索引

### 关键概念

- **回表**：通过普通索引查主键，再通过主键查完整数据
- **索引下推（ICP）**：在索引遍历时过滤条件，减少回表
- **页分裂**：插入数据导致页满，分裂影响性能
- **覆盖索引**：查询列都在索引中，无需回表

---

## 课后思考

1. 为什么推荐使用自增主键而不是业务主键？
   - 提示：考虑页分裂、索引大小

2. 什么时候适合使用覆盖索引？
   - 提示：查询列、索引列

3. 联合索引(a, b, c)可以支持哪些查询？
   - 提示：最左前缀原则

4. 为什么普通索引需要回表？能否避免？
   - 提示：二级索引存储内容、覆盖索引

---

## 下一步

完成本讲后，继续学习：
- **04-锁机制.md**：理解MySQL的全局锁、表锁、行锁

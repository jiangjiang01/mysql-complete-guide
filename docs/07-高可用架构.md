# 07-高可用架构

> 对应课程：第23-29讲（数据可靠性、主从复制、高可用方案）
> 学习时间：3-4小时
> 前置要求：已完成06-查询优化学习

---

## 核心知识点概览

### 本章内容

- **第23讲**：MySQL如何保证数据不丢
- **第24讲**：MySQL如何保证主备一致
- **第25讲**：MySQL如何保证高可用
- **第26讲**：备库延迟问题
- **第27讲**：主库故障处理
- **第28讲**：读写分离的坑
- **第29讲**：如何判断数据库健康

---

## 第23讲：数据不丢失

### 核心知识点

**数据持久化保证**：

1. **binlog写入机制**：
   - `sync_binlog=0`：写入文件系统cache，由OS决定刷盘
   - `sync_binlog=1`：每次提交都刷盘（**推荐**）
   - `sync_binlog=N`：每N次提交刷盘

2. **redo log写入机制**：
   - `innodb_flush_log_at_trx_commit=0`：每秒刷盘（可能丢1秒）
   - `innodb_flush_log_at_trx_commit=1`：每次提交刷盘（**推荐**）
   - `innodb_flush_log_at_trx_commit=2`：写入OS cache，每秒刷盘

**双1配置**（最安全）：
```sql
sync_binlog = 1
innodb_flush_log_at_trx_commit = 1
```

### 实操练习

```sql
-- 查看当前配置
SHOW VARIABLES LIKE 'sync_binlog';
SHOW VARIABLES LIKE 'innodb_flush_log_at_trx_commit';

-- 推荐配置（最安全）
SET GLOBAL sync_binlog = 1;
SET GLOBAL innodb_flush_log_at_trx_commit = 1;

-- 性能与安全的权衡：
-- 双1配置：最安全，性能较低
-- sync_binlog=1, innodb_flush_log_at_trx_commit=2：可能丢失少量事务
-- sync_binlog=0, innodb_flush_log_at_trx_commit=0：性能最好，但可能丢较多数据

-- 查看binlog刷盘次数
SHOW GLOBAL STATUS LIKE 'Binlog_cache_disk_use';

-- 查看redo log相关状态
SHOW ENGINE INNODB STATUS\G
-- 查看LOG部分

-- 测试数据持久化
USE mysql_study;

CREATE TABLE persist_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data VARCHAR(100)
) ENGINE=InnoDB;

-- 开启事务写入数据
START TRANSACTION;
INSERT INTO persist_test (data) VALUES ('test data');
COMMIT;

-- 查询binlog事件
SHOW BINLOG EVENTS IN 'binlog.000001' FROM 0 LIMIT 10;

-- 查看binlog文件大小
SHOW BINARY LOGS;
```

---

## 第24讲：主备一致性

### 核心知识点

**主从复制流程**：
```
1. 主库：写入binlog
2. 主库：binlog dump线程发送binlog
3. 从库：IO线程接收binlog，写入relay log
4. 从库：SQL线程读取relay log，执行SQL
```

**binlog格式对比**：

| 格式 | 记录内容 | 优点 | 缺点 |
|------|---------|------|------|
| STATEMENT | SQL语句 | 日志量小 | 可能不一致（如NOW()）|
| ROW | 行变化 | 保证一致 | 日志量大 |
| MIXED | 混合 | 兼顾 | 复杂 |

**推荐**：ROW格式

### 实操练习

```bash
# 搭建主从复制（使用Docker）

# 1. 启动主库
docker run --name mysql-master \
  -e MYSQL_ROOT_PASSWORD=123456 \
  -p 3307:3306 \
  -v ~/mysql-master-data:/var/lib/mysql \
  -v ~/mysql-master-conf:/etc/mysql/conf.d \
  -d mysql:8.0

# 2. 配置主库（/etc/mysql/conf.d/my.cnf）
cat > ~/mysql-master-conf/my.cnf << EOF
[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
EOF

# 重启主库
docker restart mysql-master

# 3. 启动从库
docker run --name mysql-slave \
  -e MYSQL_ROOT_PASSWORD=123456 \
  -p 3308:3306 \
  -v ~/mysql-slave-data:/var/lib/mysql \
  -v ~/mysql-slave-conf:/etc/mysql/conf.d \
  -d mysql:8.0

# 4. 配置从库
cat > ~/mysql-slave-conf/my.cnf << EOF
[mysqld]
server-id=2
relay-log=mysql-relay-bin
read-only=1
EOF

# 重启从库
docker restart mysql-slave
```

```sql
-- === 主库操作 ===

-- 创建复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'repl123';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;

-- 查看主库状态
SHOW MASTER STATUS;
-- 记录File和Position

-- 示例输出：
-- +------------------+----------+--------------+------------------+
-- | File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
-- +------------------+----------+--------------+------------------+
-- | mysql-bin.000001 |      157 |              |                  |
-- +------------------+----------+--------------+------------------+
```

```sql
-- === 从库操作 ===

-- 配置主从关系
CHANGE MASTER TO
  MASTER_HOST='<主库IP>',
  MASTER_PORT=3307,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=157;

-- 启动从库复制
START SLAVE;

-- 查看从库状态
SHOW SLAVE STATUS\G

-- 关键字段：
-- Slave_IO_Running: Yes
-- Slave_SQL_Running: Yes
-- Seconds_Behind_Master: 0
-- Last_Error: (空表示无错误)
```

```sql
-- === 测试主从复制 ===

-- 在主库创建数据库
-- 主库执行：
CREATE DATABASE repl_test;
USE repl_test;

CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50)
) ENGINE=InnoDB;

INSERT INTO users (name) VALUES ('Alice'), ('Bob');

-- 从库查询：
USE repl_test;
SELECT * FROM users;
-- 应该能看到相同数据

-- 查看从库binlog格式
SHOW VARIABLES LIKE 'binlog_format';

-- 查看relay log
SHOW RELAYLOG EVENTS;
```

---

## 第25讲：高可用方案

### 核心知识点

**高可用架构**：

1. **主从复制（Master-Slave）**：
   - 一主多从
   - 主库挂掉需手动切换

2. **MHA（Master High Availability）**：
   - 自动故障切换
   - 最多停机10-30秒

3. **MGR（MySQL Group Replication）**：
   - MySQL官方方案
   - 自动故障切换
   - 单主或多主模式

4. **云厂商方案**：
   - 阿里云RDS、腾讯云CDB等
   - 自动主备切换

### 实操练习

```sql
-- 模拟主库故障切换

-- === 场景：主库故障，切换从库为新主库 ===

-- 1. 从库停止复制
STOP SLAVE;

-- 2. 检查从库是否完全同步
SHOW SLAVE STATUS\G
-- Seconds_Behind_Master应该为0

-- 3. 将从库提升为主库
-- 去除read-only限制
SET GLOBAL read_only = 0;

-- 启用binlog（如果未启用）
-- 需要修改配置文件并重启

-- 4. 重置从库配置
RESET SLAVE ALL;

-- 5. 应用层切换连接到新主库

-- 6. 旧主库恢复后，配置为新的从库
-- 在旧主库执行：
CHANGE MASTER TO
  MASTER_HOST='<新主库IP>',
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123',
  MASTER_AUTO_POSITION=1;  -- GTID模式

START SLAVE;

-- === GTID模式配置（推荐）===

-- GTID（Global Transaction Identifier）优势：
-- 1. 自动定位binlog位置
-- 2. 简化故障切换

-- 主库配置
-- gtid_mode=ON
-- enforce_gtid_consistency=ON

-- 从库配置
CHANGE MASTER TO
  MASTER_HOST='<主库IP>',
  MASTER_USER='repl',
  MASTER_PASSWORD='repl123',
  MASTER_AUTO_POSITION=1;

START SLAVE;

-- 查看GTID状态
SHOW VARIABLES LIKE '%gtid%';
```

---

## 第26讲：备库延迟

### 核心知识点

**主备延迟原因**：
1. 从库机器性能差
2. 从库压力大（大量查询）
3. 大事务（如大批量DELETE）
4. 从库并行复制能力不足

**解决方案**：
1. 并行复制（MySQL 5.7+）
2. 升级从库硬件
3. 减少从库查询压力
4. 优化大事务

### 实操练习

```sql
-- 查看主备延迟
SHOW SLAVE STATUS\G
-- Seconds_Behind_Master: 延迟秒数

-- 开启并行复制（MySQL 5.7+）
STOP SLAVE SQL_THREAD;

-- 设置并行复制
SET GLOBAL slave_parallel_type = 'LOGICAL_CLOCK';
SET GLOBAL slave_parallel_workers = 4;  -- 根据CPU核数设置

START SLAVE SQL_THREAD;

-- 查看并行复制状态
SHOW SLAVE STATUS\G
-- Worker_Id: 各个worker的ID

-- MySQL 8.0增强的并行复制
SET GLOBAL slave_parallel_type = 'LOGICAL_CLOCK';
SET GLOBAL slave_preserve_commit_order = ON;  -- 保证提交顺序
SET GLOBAL slave_parallel_workers = 8;

-- 监控从库SQL线程
SELECT * FROM performance_schema.replication_applier_status_by_worker;

-- 查看大事务
-- 主库执行：
SELECT
    id,
    user,
    host,
    db,
    command,
    time,
    state,
    info
FROM information_schema.PROCESSLIST
WHERE command = 'Query' AND time > 10;

-- 优化大事务：拆分为小事务
-- 错误示例：
DELETE FROM large_table WHERE create_time < '2023-01-01';

-- 正确示例：批量删除
DELIMITER $$
CREATE PROCEDURE batch_delete()
BEGIN
    DECLARE done INT DEFAULT 0;
    WHILE done = 0 DO
        DELETE FROM large_table
        WHERE create_time < '2023-01-01'
        LIMIT 1000;

        IF ROW_COUNT() = 0 THEN
            SET done = 1;
        END IF;

        -- 暂停，避免持续占用资源
        DO SLEEP(0.1);
    END WHILE;
END$$
DELIMITER ;

CALL batch_delete();
```

---

## 第27讲：主库故障处理

### 核心知识点

**主库故障场景**：
1. 主库宕机
2. 部分从库未同步完成

**可靠性优先策略**：
1. 等待所有从库同步完成
2. 选择一个从库切换为主库
3. 应用层切换连接

**可用性优先策略**：
1. 立即选择一个从库切换为主库
2. 可能丢失部分数据
3. 快速恢复服务

### 实操练习

```sql
-- === 场景1：可靠性优先切换 ===

-- 步骤1：在所有从库查看同步状态
-- 从库A：
SHOW SLAVE STATUS\G
-- Relay_Master_Log_File: mysql-bin.000003
-- Exec_Master_Log_Pos: 1234

-- 从库B：
SHOW SLAVE STATUS\G
-- Relay_Master_Log_File: mysql-bin.000003
-- Exec_Master_Log_Pos: 1234

-- 步骤2：选择同步最完整的从库（位置最大的）

-- 步骤3：该从库停止复制
STOP SLAVE;

-- 步骤4：等待relay log完全应用
-- 直到Relay_Master_Log_File和Master_Log_File一致

-- 步骤5：提升为主库
SET GLOBAL read_only = 0;
RESET SLAVE ALL;

-- 步骤6：其他从库重新配置主库
-- 在其他从库执行：
STOP SLAVE;

CHANGE MASTER TO
  MASTER_HOST='<新主库IP>',
  MASTER_AUTO_POSITION=1;  -- 使用GTID

START SLAVE;

-- === 场景2：可用性优先切换 ===

-- 立即选择一个从库
STOP SLAVE;
SET GLOBAL read_only = 0;
RESET SLAVE ALL;

-- 应用层立即切换连接
-- 可能丢失部分未同步的事务

-- 查看可能丢失的事务
SHOW BINLOG EVENTS IN 'mysql-bin.000003' FROM 1234;
```

---

## 第28讲：读写分离

### 核心知识点

**读写分离架构**：
```
应用层
  ├─ 写：主库
  └─ 读：从库（多个）
```

**常见问题**：
1. **过期读**：从库延迟导致读到旧数据
2. **分配策略**：如何选择从库

**解决方案**：
1. 强一致读：主库读
2. 允许延迟：从库读
3. 半同步复制：保证至少一个从库同步

### 实操练习

```sql
-- 场景1：过期读问题

-- 主库写入
INSERT INTO users (name) VALUES ('Charlie');

-- 立即从从库读
-- 可能读不到（从库延迟）
SELECT * FROM users WHERE name = 'Charlie';

-- 解决方案1：强制主库读
-- 应用层判断：写后立即读，从主库读

-- 解决方案2：半同步复制
-- 主库配置：
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_master_timeout = 1000;  -- 1秒超时

-- 从库配置：
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
SET GLOBAL rpl_semi_sync_slave_enabled = 1;

STOP SLAVE IO_THREAD;
START SLAVE IO_THREAD;

-- 查看半同步状态
SHOW STATUS LIKE 'Rpl_semi_sync%';

-- 解决方案3：判断延迟
-- 查询前检查从库延迟
SHOW SLAVE STATUS\G
-- 如果Seconds_Behind_Master > 1，从主库读

-- 解决方案4：GTID判断
-- 等待从库同步到指定GTID
SELECT WAIT_FOR_EXECUTED_GTID_SET('uuid:transaction_id', 1);
-- 返回0表示已同步，返回1表示超时

-- 应用示例：
-- 1. 主库写入后，获取GTID
SHOW MASTER STATUS;

-- 2. 从库读取前，等待GTID
SELECT WAIT_FOR_EXECUTED_GTID_SET('主库GTID', 1);

-- 3. 同步完成后，从从库读取
```

---

## 第29讲：数据库健康检查

### 核心知识点

**健康检查指标**：
1. **连接性**：能否连接
2. **查询性能**：SELECT 1
3. **更新性能**：更新检测表
4. **主备延迟**：Seconds_Behind_Master

**推荐方案**：
- 正常监控：SELECT 1
- 关键监控：更新检测表
- 主从监控：延迟时间

### 实操练习

```sql
-- 方案1：连接性检查（最简单）
-- 应用层定期执行
SELECT 1;

-- 方案2：查询性能检查
-- 创建检测表
CREATE TABLE health_check (
    id INT PRIMARY KEY,
    last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB;

INSERT INTO health_check VALUES (1, NOW());

-- 定期查询
SELECT * FROM health_check WHERE id = 1;

-- 方案3：更新性能检查（更全面）
-- 定期更新
UPDATE health_check SET last_update = NOW() WHERE id = 1;

-- 如果更新失败或超时，说明数据库有问题

-- 方案4：主备延迟检查
-- 定期检查
SHOW SLAVE STATUS\G
-- Seconds_Behind_Master > 阈值（如5秒），告警

-- 方案5：使用Prometheus + Mysqld Exporter
-- 监控指标：
-- - mysql_up：数据库是否存活
-- - mysql_global_status_threads_connected：连接数
-- - mysql_global_status_slow_queries：慢查询数
-- - mysql_slave_status_seconds_behind_master：主备延迟

-- 查看当前连接数
SHOW STATUS LIKE 'Threads_connected';

-- 查看最大连接数
SHOW VARIABLES LIKE 'max_connections';

-- 查看慢查询数
SHOW GLOBAL STATUS LIKE 'Slow_queries';

-- 设置告警阈值
-- - 连接数 > max_connections * 0.8
-- - 慢查询数突增
-- - 主备延迟 > 5秒
```

---

## 重点总结

### 数据可靠性

1. **双1配置**（最安全）：
   ```sql
   sync_binlog = 1
   innodb_flush_log_at_trx_commit = 1
   ```

2. **binlog格式**：推荐ROW

### 主从复制

3. **复制流程**：
   - 主库：binlog
   - 从库：IO线程 → relay log → SQL线程

4. **故障切换**：
   - 可靠性优先：等待同步完成
   - 可用性优先：快速切换，可能丢数据

5. **备库延迟**：
   - 开启并行复制
   - 优化大事务
   - 升级硬件

### 读写分离

6. **过期读问题**：
   - 强制主库读
   - 半同步复制
   - WAIT_FOR_EXECUTED_GTID_SET

7. **健康检查**：
   - SELECT 1（连接性）
   - 更新检测表（更新性能）
   - 监控主备延迟

---

## 课后思考

1. 为什么推荐binlog使用ROW格式？
2. 半同步复制如何解决过期读问题？
3. 如何选择可靠性优先还是可用性优先策略？
4. 主备延迟的根本原因是什么？如何优化？

---

## 下一步

完成本讲后，继续学习：
- **08-进阶主题.md**：JOIN优化、临时表、分区表等进阶内容

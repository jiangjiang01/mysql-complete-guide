# 03-表关系设计

> 掌握一对一、一对多、多对多关系的设计方法，构建合理的数据库结构

---

## 📖 本章目标

- 理解表关系的类型
- 掌握一对一关系的设计方法
- 掌握一对多关系的设计方法
- 掌握多对多关系的设计方法
- 理解自关联的设计场景和方法

---

## 一、表关系类型概述

### 1.1 三种基本关系

```
一对一（1:1）
- 用户 - 用户资料
- 用户 - 身份证信息

一对多（1:N）
- 用户 - 订单
- 分类 - 商品

多对多（M:N）
- 文章 - 标签
- 学生 - 课程
```

### 1.2 关系的表达方式

**方式一：外键约束（数据库层面）**
```sql
FOREIGN KEY (user_id) REFERENCES users(id)
```

**方式二：应用层控制（推荐）**
```sql
-- 只存储关联ID，不使用外键约束
user_id BIGINT UNSIGNED NOT NULL
INDEX idx_user_id (user_id)
```

---

## 二、一对一关系设计

### 2.1 一对一关系场景

**适用场景**：
1. **性能优化**：将大字段分离到扩展表
2. **安全隔离**：将敏感信息分离
3. **业务分离**：将不同业务模块的数据分离

### 2.2 设计方式一：主表 + 扩展表

#### 示例：用户表 + 用户资料表

```sql
-- 主表：核心信息
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(20) NOT NULL DEFAULT '',
    password VARCHAR(255) NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email)
) ENGINE=InnoDB COMMENT='用户表';

-- 扩展表：扩展信息
CREATE TABLE user_profiles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL COMMENT '用户ID',

    -- 扩展字段
    nickname VARCHAR(50) NOT NULL DEFAULT '',
    avatar VARCHAR(255) NOT NULL DEFAULT '',
    gender TINYINT UNSIGNED NOT NULL DEFAULT 0,
    birthday DATE DEFAULT NULL,
    bio TEXT COMMENT '个人简介',
    address VARCHAR(255) NOT NULL DEFAULT '',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    -- 唯一索引：一对一关系
    UNIQUE KEY uniq_user_id (user_id)
) ENGINE=InnoDB COMMENT='用户资料表';

-- 插入数据
INSERT INTO users (username, email, phone, password) VALUES
('zhangsan', 'zhangsan@example.com', '13800138000', 'hashed_password');

-- 获取插入的用户ID
SET @user_id = LAST_INSERT_ID();

-- 插入用户资料
INSERT INTO user_profiles (user_id, nickname, gender, birthday) VALUES
(@user_id, '张三', 1, '1990-01-01');

-- 查询：关联查询
SELECT
    u.id,
    u.username,
    u.email,
    up.nickname,
    up.gender,
    up.birthday,
    up.bio
FROM users u
LEFT JOIN user_profiles up ON u.id = up.user_id
WHERE u.id = @user_id;
```

#### 为什么要分表？

```sql
-- ❌ 不分表：所有字段在一张表
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    password VARCHAR(255) NOT NULL,

    -- 扩展字段混在一起
    nickname VARCHAR(50),
    avatar VARCHAR(255),
    gender TINYINT UNSIGNED,
    birthday DATE,
    bio TEXT,              -- 大字段
    address VARCHAR(255)
) ENGINE=InnoDB;

-- 问题：
-- 1. 查询用户列表时，bio字段会影响性能
-- 2. 表结构混乱，不易维护
-- 3. 索引效率降低

-- ✅ 分表：核心信息 + 扩展信息
-- 优点：
-- 1. 查询用户列表时，不加载bio字段
-- 2. 表结构清晰
-- 3. 扩展灵活
```

### 2.3 设计方式二：敏感信息分离

#### 示例：用户表 + 用户认证信息表

```sql
-- 主表：基本信息
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(20) NOT NULL DEFAULT '',
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email)
) ENGINE=InnoDB;

-- 敏感信息表：密码、令牌等
CREATE TABLE user_auth (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,

    -- 敏感字段
    password VARCHAR(255) NOT NULL COMMENT '密码（BCrypt）',
    salt VARCHAR(64) NOT NULL DEFAULT '' COMMENT '盐值',
    access_token VARCHAR(255) NOT NULL DEFAULT '',
    refresh_token VARCHAR(255) NOT NULL DEFAULT '',
    token_expires_at DATETIME DEFAULT NULL,

    -- 安全信息
    failed_login_count TINYINT UNSIGNED NOT NULL DEFAULT 0,
    locked_until DATETIME DEFAULT NULL,

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_user_id (user_id)
) ENGINE=InnoDB COMMENT='用户认证信息表';

-- 优点：
-- 1. 敏感信息隔离，权限控制更严格
-- 2. 主表可以放心缓存
-- 3. 认证信息表可以单独备份和加密
```

### 2.4 外键约束 vs 应用层控制

#### 方式一：使用外键约束

```sql
CREATE TABLE user_profiles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    nickname VARCHAR(50) NOT NULL DEFAULT '',

    UNIQUE KEY uniq_user_id (user_id),

    -- 外键约束
    CONSTRAINT fk_user_profiles_user_id
        FOREIGN KEY (user_id) REFERENCES users(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
) ENGINE=InnoDB;

-- 优点：
-- 1. 数据库层面保证引用完整性
-- 2. 级联删除/更新

-- 缺点：
-- 1. 性能开销（每次插入/更新/删除都要检查）
-- 2. 分库分表困难
-- 3. 灵活性差
```

#### 方式二：应用层控制（推荐）

```sql
CREATE TABLE user_profiles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    nickname VARCHAR(50) NOT NULL DEFAULT '',

    UNIQUE KEY uniq_user_id (user_id)
    -- 不使用外键约束，由应用层保证数据完整性
) ENGINE=InnoDB;

-- 应用层逻辑（伪代码）
function deleteUser(userId) {
    // 开启事务
    beginTransaction();

    try {
        // 删除用户资料
        DELETE FROM user_profiles WHERE user_id = userId;

        // 删除用户
        DELETE FROM users WHERE id = userId;

        // 提交事务
        commit();
    } catch (error) {
        // 回滚事务
        rollback();
    }
}

-- 优点：
-- 1. 性能好
-- 2. 灵活性高
-- 3. 便于分库分表
```

**推荐做法**：
- ✅ **使用应用层控制**
- ✅ **添加索引**：`INDEX idx_user_id (user_id)`
- ✅ **在应用层保证数据完整性**

---

## 三、一对多关系设计

### 3.1 一对多关系场景

**典型场景**：
- 用户 - 订单（一个用户有多个订单）
- 分类 - 商品（一个分类有多个商品）
- 文章 - 评论（一篇文章有多条评论）

### 3.2 基本设计

#### 示例：用户 - 订单

```sql
-- 一方：用户表
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 多方：订单表
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,

    -- 外键字段：指向用户表
    user_id BIGINT UNSIGNED NOT NULL COMMENT '用户ID',

    total_amount BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_order_no (order_no),

    -- 索引：加速查询某用户的订单
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO users (username, email) VALUES
('zhangsan', 'zhangsan@example.com');

SET @user_id = LAST_INSERT_ID();

INSERT INTO orders (order_no, user_id, total_amount, status) VALUES
('ORDER001', @user_id, 10000, 1),
('ORDER002', @user_id, 20000, 2),
('ORDER003', @user_id, 15000, 1);

-- 查询：某用户的所有订单
SELECT * FROM orders WHERE user_id = @user_id;

-- 查询：关联查询
SELECT
    u.username,
    u.email,
    o.order_no,
    o.total_amount,
    o.status,
    o.created_at
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.id = @user_id;

-- 查询：统计每个用户的订单数
SELECT
    u.id,
    u.username,
    COUNT(o.id) AS order_count,
    IFNULL(SUM(o.total_amount), 0) AS total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username;
```

### 3.3 一对多关系的索引设计

```sql
-- 多方表必须添加索引
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- ✅ 必须：基础索引
    INDEX idx_user_id (user_id),

    -- ✅ 推荐：联合索引（常见查询模式）
    INDEX idx_user_status_created (user_id, status, created_at)
) ENGINE=InnoDB;

-- 查询优化
-- 查询1：某用户的所有订单
EXPLAIN SELECT * FROM orders WHERE user_id = 1;
-- 使用：idx_user_id

-- 查询2：某用户的待支付订单
EXPLAIN SELECT * FROM orders WHERE user_id = 1 AND status = 1;
-- 使用：idx_user_status_created

-- 查询3：某用户最近的订单
EXPLAIN SELECT * FROM orders
WHERE user_id = 1
ORDER BY created_at DESC
LIMIT 10;
-- 使用：idx_user_status_created
```

### 3.4 级联操作处理

#### 示例：删除用户时如何处理订单？

**方案一：禁止删除**
```sql
-- 应用层逻辑
function deleteUser(userId) {
    // 检查是否有订单
    count = SELECT COUNT(*) FROM orders WHERE user_id = userId;

    if (count > 0) {
        throw new Error('用户有订单，无法删除');
    }

    DELETE FROM users WHERE id = userId;
}
```

**方案二：软删除用户**
```sql
-- 用户表添加deleted_at字段
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    deleted_at DATETIME DEFAULT NULL,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 软删除
UPDATE users SET deleted_at = NOW() WHERE id = 1;

-- 查询时过滤已删除用户
SELECT * FROM users WHERE deleted_at IS NULL;
```

**方案三：级联删除（慎用）**
```sql
-- 仅在合适的场景使用，如：文章删除时删除评论
function deleteArticle(articleId) {
    beginTransaction();

    try {
        -- 删除评论
        DELETE FROM comments WHERE article_id = articleId;

        -- 删除文章
        DELETE FROM articles WHERE id = articleId;

        commit();
    } catch (error) {
        rollback();
    }
}
```

---

## 四、多对多关系设计

### 4.1 多对多关系场景

**典型场景**：
- 文章 - 标签
- 学生 - 课程
- 用户 - 角色
- 商品 - 促销活动

### 4.2 基本设计：中间表

#### 示例：文章 - 标签

```sql
-- 表1：文章表
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    author_id BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_author_id (author_id)
) ENGINE=InnoDB;

-- 表2：标签表
CREATE TABLE tags (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_name (name)
) ENGINE=InnoDB;

-- 中间表：文章-标签关联表
CREATE TABLE article_tags (
    article_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 复合主键：防止重复关联
    PRIMARY KEY (article_id, tag_id),

    -- 索引：查询某标签下的文章
    INDEX idx_tag_id (tag_id)
) ENGINE=InnoDB COMMENT='文章标签关联表';

-- 插入数据
INSERT INTO articles (title, content, author_id) VALUES
('MySQL教程', '这是一篇MySQL教程...', 1);

SET @article_id = LAST_INSERT_ID();

INSERT INTO tags (name) VALUES
('数据库'),
('MySQL'),
('教程');

-- 关联文章和标签
INSERT INTO article_tags (article_id, tag_id) VALUES
(@article_id, 1),  -- 文章 -> 数据库
(@article_id, 2),  -- 文章 -> MySQL
(@article_id, 3);  -- 文章 -> 教程

-- 查询1：某文章的所有标签
SELECT
    t.id,
    t.name
FROM tags t
JOIN article_tags at ON t.id = at.tag_id
WHERE at.article_id = @article_id;

-- 查询2：某标签下的所有文章
SELECT
    a.id,
    a.title,
    a.created_at
FROM articles a
JOIN article_tags at ON a.id = at.article_id
WHERE at.tag_id = 1;

-- 查询3：文章及其标签（GROUP_CONCAT）
SELECT
    a.id,
    a.title,
    GROUP_CONCAT(t.name ORDER BY t.name SEPARATOR ', ') AS tags
FROM articles a
LEFT JOIN article_tags at ON a.id = at.article_id
LEFT JOIN tags t ON at.tag_id = t.id
GROUP BY a.id, a.title;
```

### 4.3 中间表的主键设计

#### 方案一：复合主键（推荐）

```sql
CREATE TABLE article_tags (
    article_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,

    -- 复合主键
    PRIMARY KEY (article_id, tag_id),
    INDEX idx_tag_id (tag_id)
) ENGINE=InnoDB;

-- 优点：
-- 1. 语义清晰
-- 2. 节省空间（少一个id字段）
-- 3. 主键即是查询条件，效率高

-- 缺点：
-- 1. JOIN时需要两个字段
```

#### 方案二：自增ID + 联合唯一索引

```sql
CREATE TABLE article_tags (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    article_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 联合唯一索引：防止重复
    UNIQUE KEY uniq_article_tag (article_id, tag_id),
    INDEX idx_tag_id (tag_id)
) ENGINE=InnoDB;

-- 优点：
-- 1. 有独立ID，便于引用
-- 2. 可以添加更多字段

-- 缺点：
-- 1. 多一个字段，占用空间
```

**选择建议**：
- 如果**仅存储关联关系**，使用**复合主键**
- 如果**需要额外字段**（如创建时间、排序、权限等），使用**自增ID**

### 4.4 中间表的扩展字段

#### 示例：用户-角色关联（带权限授予信息）

```sql
CREATE TABLE user_roles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    role_id BIGINT UNSIGNED NOT NULL,

    -- 扩展字段
    granted_by BIGINT UNSIGNED NOT NULL COMMENT '授权人ID',
    granted_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '授权时间',
    expires_at DATETIME DEFAULT NULL COMMENT '过期时间',
    remark VARCHAR(255) NOT NULL DEFAULT '' COMMENT '备注',

    UNIQUE KEY uniq_user_role (user_id, role_id),
    INDEX idx_role_id (role_id),
    INDEX idx_granted_by (granted_by),
    INDEX idx_expires_at (expires_at)
) ENGINE=InnoDB;

-- 插入数据（授予角色）
INSERT INTO user_roles (user_id, role_id, granted_by, granted_at, expires_at) VALUES
(1, 2, 100, NOW(), DATE_ADD(NOW(), INTERVAL 1 YEAR));

-- 查询：某用户的所有有效角色
SELECT
    r.id,
    r.name AS role_name,
    ur.granted_at,
    ur.expires_at
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.user_id = 1
AND (ur.expires_at IS NULL OR ur.expires_at > NOW());
```

---

## 五、自关联设计

### 5.1 自关联场景

**典型场景**：
- 部门层级（父部门-子部门）
- 商品分类（父分类-子分类）
- 评论回复（评论-子评论）
- 组织架构（上级-下级）

### 5.2 邻接表模型（Adjacency List）

#### 示例：商品分类

```sql
CREATE TABLE categories (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,

    -- 自关联字段
    parent_id BIGINT UNSIGNED DEFAULT NULL COMMENT '父分类ID',

    level TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '层级：1-一级分类，2-二级分类',
    sort_order INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '排序',
    is_leaf TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '是否叶子节点：0-否，1-是',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_parent_id (parent_id),
    INDEX idx_level (level),
    INDEX idx_sort_order (sort_order)
) ENGINE=InnoDB COMMENT='商品分类表';

-- 插入数据
-- 一级分类
INSERT INTO categories (id, name, parent_id, level, is_leaf) VALUES
(1, '电子产品', NULL, 1, 0),
(2, '图书', NULL, 1, 0),
(3, '服装', NULL, 1, 0);

-- 二级分类
INSERT INTO categories (id, name, parent_id, level, is_leaf) VALUES
(11, '手机', 1, 2, 1),
(12, '电脑', 1, 2, 1),
(13, '平板', 1, 2, 1),
(21, '小说', 2, 2, 1),
(22, '技术书籍', 2, 2, 1);

-- 查询1：所有一级分类
SELECT * FROM categories WHERE parent_id IS NULL ORDER BY sort_order;

-- 查询2：某一级分类下的所有二级分类
SELECT * FROM categories WHERE parent_id = 1 ORDER BY sort_order;

-- 查询3：某分类的父分类
SELECT
    c.id,
    c.name,
    p.id AS parent_id,
    p.name AS parent_name
FROM categories c
LEFT JOIN categories p ON c.parent_id = p.id
WHERE c.id = 11;

-- 查询4：分类树（两级）
SELECT
    p.id AS p_id,
    p.name AS p_name,
    c.id AS c_id,
    c.name AS c_name
FROM categories p
LEFT JOIN categories c ON p.id = c.parent_id
WHERE p.parent_id IS NULL
ORDER BY p.sort_order, c.sort_order;
```

#### 邻接表模型的优缺点

**优点**：
- ✅ 结构简单，易于理解
- ✅ 插入、更新、删除节点容易

**缺点**：
- ❌ 查询所有子孙节点困难（需要递归）
- ❌ 查询祖先路径困难
- ❌ 性能差（多层级需要多次查询）

### 5.3 路径枚举模型（Path Enumeration）

#### 示例：评论回复（带路径）

```sql
CREATE TABLE comments (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    article_id BIGINT UNSIGNED NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,
    content TEXT NOT NULL,

    -- 路径字段
    parent_id BIGINT UNSIGNED DEFAULT NULL COMMENT '父评论ID',
    path VARCHAR(500) NOT NULL DEFAULT '' COMMENT '路径：/1/3/5/',
    level TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '层级',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_article_id (article_id),
    INDEX idx_parent_id (parent_id),
    INDEX idx_path (path(100))
) ENGINE=InnoDB COMMENT='评论表';

-- 插入数据
-- 一级评论
INSERT INTO comments (id, article_id, user_id, content, parent_id, path, level) VALUES
(1, 100, 1, '这篇文章不错', NULL, '/1/', 1),
(2, 100, 2, '写得很好', NULL, '/2/', 1);

-- 二级评论（回复1号评论）
INSERT INTO comments (id, article_id, user_id, content, parent_id, path, level) VALUES
(3, 100, 3, '同意楼上', 1, '/1/3/', 2),
(4, 100, 4, '+1', 1, '/1/4/', 2);

-- 三级评论（回复3号评论）
INSERT INTO comments (id, article_id, user_id, content, parent_id, path, level) VALUES
(5, 100, 5, '我也觉得', 3, '/1/3/5/', 3);

-- 查询1：某文章的所有一级评论
SELECT * FROM comments
WHERE article_id = 100 AND parent_id IS NULL
ORDER BY created_at;

-- 查询2：某评论的所有子孙评论
SELECT * FROM comments
WHERE path LIKE '/1/%'
ORDER BY path;

-- 查询3：评论树结构
SELECT
    id,
    content,
    level,
    path,
    CONCAT(REPEAT('  ', level - 1), content) AS tree_content
FROM comments
WHERE article_id = 100
ORDER BY path;
-- 结果：
-- 这篇文章不错
--   同意楼上
--     我也觉得
--   +1
-- 写得很好
```

#### 路径枚举模型的优缺点

**优点**：
- ✅ 查询子孙节点简单（LIKE '/1/%'）
- ✅ 查询祖先路径简单（解析path字段）

**缺点**：
- ❌ path字段占用空间
- ❌ 移动节点复杂（需要更新所有子孙节点的path）

### 5.4 闭包表模型（Closure Table）

#### 示例：部门层级（最灵活的方案）

```sql
-- 部门表
CREATE TABLE departments (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- 部门关系表（闭包表）
CREATE TABLE department_relations (
    ancestor_id BIGINT UNSIGNED NOT NULL COMMENT '祖先节点ID',
    descendant_id BIGINT UNSIGNED NOT NULL COMMENT '后代节点ID',
    distance TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '距离：0-自己，1-直接子节点',

    PRIMARY KEY (ancestor_id, descendant_id),
    INDEX idx_descendant_id (descendant_id)
) ENGINE=InnoDB COMMENT='部门关系表';

-- 插入数据
INSERT INTO departments (id, name) VALUES
(1, '总公司'),
(2, '研发部'),
(3, '市场部'),
(4, '后端组'),
(5, '前端组');

-- 插入关系（每个节点都要插入自己到自己的关系）
-- 总公司
INSERT INTO department_relations (ancestor_id, descendant_id, distance) VALUES (1, 1, 0);

-- 研发部（总公司的子部门）
INSERT INTO department_relations (ancestor_id, descendant_id, distance) VALUES
(2, 2, 0),  -- 自己
(1, 2, 1);  -- 父节点

-- 市场部（总公司的子部门）
INSERT INTO department_relations (ancestor_id, descendant_id, distance) VALUES
(3, 3, 0),
(1, 3, 1);

-- 后端组（研发部的子部门）
INSERT INTO department_relations (ancestor_id, descendant_id, distance) VALUES
(4, 4, 0),  -- 自己
(2, 4, 1),  -- 父节点（研发部）
(1, 4, 2);  -- 祖先节点（总公司）

-- 前端组（研发部的子部门）
INSERT INTO department_relations (ancestor_id, descendant_id, distance) VALUES
(5, 5, 0),
(2, 5, 1),
(1, 5, 2);

-- 查询1：某部门的所有子部门
SELECT
    d.id,
    d.name,
    dr.distance
FROM department_relations dr
JOIN departments d ON dr.descendant_id = d.id
WHERE dr.ancestor_id = 1  -- 总公司
AND dr.distance > 0       -- 不包括自己
ORDER BY dr.distance, d.name;

-- 查询2：某部门的直接子部门
SELECT
    d.id,
    d.name
FROM department_relations dr
JOIN departments d ON dr.descendant_id = d.id
WHERE dr.ancestor_id = 2  -- 研发部
AND dr.distance = 1       -- 直接子节点
ORDER BY d.name;

-- 查询3：某部门的所有祖先部门
SELECT
    d.id,
    d.name,
    dr.distance
FROM department_relations dr
JOIN departments d ON dr.ancestor_id = d.id
WHERE dr.descendant_id = 4  -- 后端组
AND dr.distance > 0
ORDER BY dr.distance DESC;  -- 从近到远

-- 查询4：删除某部门及其所有子部门
-- 第一步：找出所有要删除的部门ID
SELECT descendant_id FROM department_relations WHERE ancestor_id = 2;

-- 第二步：删除关系
DELETE FROM department_relations
WHERE descendant_id IN (
    SELECT descendant_id FROM department_relations WHERE ancestor_id = 2
);

-- 第三步：删除部门
DELETE FROM departments
WHERE id IN (
    SELECT descendant_id FROM department_relations WHERE ancestor_id = 2
);
```

#### 闭包表模型的优缺点

**优点**：
- ✅ 查询任意节点的祖先、后代都很简单
- ✅ 支持任意层级
- ✅ 性能好（索引友好）

**缺点**：
- ❌ 占用空间大（存储所有关系对）
- ❌ 插入、删除节点需要维护多条关系记录

---

## 六、实战案例

### 案例1：电商系统的表关系设计

```sql
-- 用户表（1）
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 商品分类表（自关联）
CREATE TABLE categories (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    parent_id BIGINT UNSIGNED DEFAULT NULL,
    level TINYINT UNSIGNED NOT NULL DEFAULT 1,

    INDEX idx_parent_id (parent_id)
) ENGINE=InnoDB;

-- 商品表（N）
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    category_id BIGINT UNSIGNED NOT NULL,  -- 一对多：分类-商品
    price_cents BIGINT UNSIGNED NOT NULL,
    stock INT UNSIGNED NOT NULL DEFAULT 0,

    INDEX idx_category_id (category_id)
) ENGINE=InnoDB;

-- 订单表（N）
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,  -- 一对多：用户-订单
    total_amount BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,

    UNIQUE KEY uniq_order_no (order_no),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 订单明细表（N）
CREATE TABLE order_items (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,  -- 一对多：订单-订单明细
    product_id BIGINT UNSIGNED NOT NULL,
    quantity INT UNSIGNED NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL,

    INDEX idx_order_id (order_id),
    INDEX idx_product_id (product_id)
) ENGINE=InnoDB;

-- 用户收藏表（多对多：用户-商品）
CREATE TABLE user_favorites (
    user_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (user_id, product_id),
    INDEX idx_product_id (product_id)
) ENGINE=InnoDB;
```

### 案例2：内容管理系统的表关系设计

```sql
-- 用户表
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 文章表
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    author_id BIGINT UNSIGNED NOT NULL,  -- 一对多：用户-文章
    category_id BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,

    INDEX idx_author_id (author_id),
    INDEX idx_category_id (category_id)
) ENGINE=InnoDB;

-- 标签表
CREATE TABLE tags (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,

    UNIQUE KEY uniq_name (name)
) ENGINE=InnoDB;

-- 文章-标签关联表（多对多）
CREATE TABLE article_tags (
    article_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,

    PRIMARY KEY (article_id, tag_id),
    INDEX idx_tag_id (tag_id)
) ENGINE=InnoDB;

-- 评论表（自关联 + 一对多）
CREATE TABLE comments (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    article_id BIGINT UNSIGNED NOT NULL,  -- 一对多：文章-评论
    user_id BIGINT UNSIGNED NOT NULL,     -- 一对多：用户-评论
    parent_id BIGINT UNSIGNED DEFAULT NULL,  -- 自关联：评论回复
    content TEXT NOT NULL,
    path VARCHAR(500) NOT NULL DEFAULT '',

    INDEX idx_article_id (article_id),
    INDEX idx_user_id (user_id),
    INDEX idx_parent_id (parent_id)
) ENGINE=InnoDB;

-- 用户关注表（多对多：用户-用户）
CREATE TABLE user_follows (
    follower_id BIGINT UNSIGNED NOT NULL,
    followee_id BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (follower_id, followee_id),
    INDEX idx_followee_id (followee_id)
) ENGINE=InnoDB;
```

---

## 七、本章总结

### 核心要点

1. **一对一关系**：
   - 用于性能优化（大字段分离）
   - 用于安全隔离（敏感信息分离）
   - 使用UNIQUE KEY保证一对一

2. **一对多关系**：
   - 多方表存储外键字段
   - 必须添加索引
   - 常见场景：用户-订单、分类-商品

3. **多对多关系**：
   - 使用中间表
   - 中间表使用复合主键或自增ID+唯一索引
   - 常见场景：文章-标签、用户-角色

4. **自关联**：
   - 邻接表：简单但查询性能差
   - 路径枚举：查询方便但更新复杂
   - 闭包表：最灵活但占用空间大

5. **外键约束**：
   - 推荐使用应用层控制
   - 添加索引提高性能
   - 便于分库分表

### 下一步

完成本章学习后，你应该能够：
- ✅ 设计一对一关系（主表+扩展表）
- ✅ 设计一对多关系（外键+索引）
- ✅ 设计多对多关系（中间表）
- ✅ 设计自关联关系（树形结构）

下一章我们将学习 **范式与反范式**，理解何时遵循范式、何时打破范式。

---

**🎉 恭喜完成第三节学习！**

下一节：[04-范式与反范式](./04-范式与反范式.md)

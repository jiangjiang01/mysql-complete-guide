# 19-索引优化实战

> 掌握索引优化技巧，提升查询性能

---

## 📖 本章目标

- 理解索引的工作原理
- 掌握索引设计原则
- 学会使用EXPLAIN分析查询
- 掌握索引优化技巧
- 避免常见索引错误

---

## 一、索引基础回顾

### 1.1 索引类型

```sql
-- 1. 主键索引（PRIMARY KEY）
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY
);

-- 2. 唯一索引（UNIQUE）
CREATE TABLE users (
    username VARCHAR(50) NOT NULL,
    UNIQUE KEY uniq_username (username)
);

-- 3. 普通索引（INDEX）
CREATE TABLE users (
    status TINYINT UNSIGNED NOT NULL,
    INDEX idx_status (status)
);

-- 4. 联合索引（多列索引）
CREATE TABLE orders (
    user_id BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL,
    INDEX idx_user_status_created (user_id, status, created_at)
);

-- 5. 全文索引（FULLTEXT）
CREATE TABLE articles (
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    FULLTEXT INDEX ft_title_content (title, content) WITH PARSER ngram
);
```

### 1.2 索引的优缺点

**优点**：
- ✅ 加快查询速度（WHERE、ORDER BY、GROUP BY）
- ✅ 唯一索引保证数据唯一性
- ✅ 加速表与表之间的连接

**缺点**：
- ❌ 占用磁盘空间
- ❌ 降低INSERT、UPDATE、DELETE性能
- ❌ 需要维护成本

---

## 二、EXPLAIN分析查询

### 2.1 EXPLAIN基础

```sql
-- 查看执行计划
EXPLAIN SELECT * FROM users WHERE username = 'zhangsan';

-- EXPLAIN输出字段说明：
-- id: SELECT标识符
-- select_type: 查询类型（SIMPLE, PRIMARY, SUBQUERY等）
-- table: 表名
-- type: 连接类型（性能从好到差：system > const > eq_ref > ref > range > index > ALL）
-- possible_keys: 可能使用的索引
-- key: 实际使用的索引
-- key_len: 使用的索引长度
-- ref: 与索引比较的列
-- rows: 预计扫描的行数
-- Extra: 额外信息
```

### 2.2 type字段详解

```sql
-- 1. system/const：常量查询（最快）
EXPLAIN SELECT * FROM users WHERE id = 1;
-- type: const

-- 2. eq_ref：唯一索引查找
EXPLAIN SELECT * FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.id = 1;
-- type: eq_ref（users表）

-- 3. ref：非唯一索引查找
EXPLAIN SELECT * FROM users WHERE status = 1;
-- type: ref

-- 4. range：范围查询
EXPLAIN SELECT * FROM orders
WHERE created_at >= '2024-01-01' AND created_at < '2024-02-01';
-- type: range

-- 5. index：索引全扫描
EXPLAIN SELECT id FROM users ORDER BY id;
-- type: index

-- 6. ALL：全表扫描（最慢）
EXPLAIN SELECT * FROM users WHERE nickname LIKE '%san%';
-- type: ALL
```

### 2.3 Extra字段详解

```sql
-- Using index：覆盖索引（不需要回表）
EXPLAIN SELECT id, username FROM users WHERE username = 'zhangsan';
-- Extra: Using index

-- Using where：使用WHERE过滤
EXPLAIN SELECT * FROM users WHERE status = 1;
-- Extra: Using where

-- Using filesort：文件排序（性能差）
EXPLAIN SELECT * FROM users ORDER BY nickname;
-- Extra: Using filesort

-- Using temporary：使用临时表（性能差）
EXPLAIN SELECT username, COUNT(*) FROM users GROUP BY username;
-- Extra: Using temporary

-- Using index condition：索引条件下推
EXPLAIN SELECT * FROM users WHERE username LIKE 'zhang%' AND status = 1;
-- Extra: Using index condition
```

---

## 三、索引设计原则

### 3.1 选择性原则

```sql
-- 选择性高的列适合建索引（重复值少）

-- ❌ 不适合建索引：性别（只有2-3个值）
CREATE INDEX idx_gender ON users(gender);  -- 不推荐

-- ✅ 适合建索引：用户名（几乎不重复）
CREATE INDEX idx_username ON users(username);  -- 推荐

-- 计算列的选择性
SELECT
    COUNT(DISTINCT gender) / COUNT(*) AS gender_selectivity,
    COUNT(DISTINCT username) / COUNT(*) AS username_selectivity
FROM users;
-- gender_selectivity: 0.5（低）
-- username_selectivity: 0.99（高）
```

### 3.2 最左前缀原则

```sql
-- 联合索引：(user_id, status, created_at)
CREATE INDEX idx_user_status_created ON orders(user_id, status, created_at);

-- ✅ 能使用索引
EXPLAIN SELECT * FROM orders WHERE user_id = 1;  -- 使用索引第1列
EXPLAIN SELECT * FROM orders WHERE user_id = 1 AND status = 2;  -- 使用索引前2列
EXPLAIN SELECT * FROM orders WHERE user_id = 1 AND status = 2 AND created_at >= '2024-01-01';  -- 使用全部索引

-- ❌ 不能使用索引
EXPLAIN SELECT * FROM orders WHERE status = 2;  -- 没有user_id
EXPLAIN SELECT * FROM orders WHERE created_at >= '2024-01-01';  -- 没有user_id

-- ⚠️ 部分使用索引
EXPLAIN SELECT * FROM orders WHERE user_id = 1 AND created_at >= '2024-01-01';
-- 使用索引的user_id部分，created_at部分不使用
```

### 3.3 覆盖索引原则

```sql
-- 覆盖索引：索引包含查询所需的所有列

-- ❌ 需要回表
CREATE INDEX idx_username ON users(username);
EXPLAIN SELECT id, username, email FROM users WHERE username = 'zhangsan';
-- Extra: 无"Using index"（需要回表获取email）

-- ✅ 覆盖索引
CREATE INDEX idx_username_email ON users(username, email);
EXPLAIN SELECT id, username, email FROM users WHERE username = 'zhangsan';
-- Extra: Using index（不需要回表）
```

### 3.4 索引长度原则

```sql
-- 对于长字符串，使用前缀索引

-- ❌ 索引整个字段（占用空间大）
CREATE INDEX idx_email ON users(email);  -- email最长100字符

-- ✅ 使用前缀索引
CREATE INDEX idx_email ON users(email(20));  -- 只索引前20个字符

-- 确定前缀长度
SELECT
    COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) AS len5_selectivity,
    COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) AS len10_selectivity,
    COUNT(DISTINCT LEFT(email, 15)) / COUNT(*) AS len15_selectivity,
    COUNT(DISTINCT LEFT(email, 20)) / COUNT(*) AS len20_selectivity,
    COUNT(DISTINCT email) / COUNT(*) AS full_selectivity
FROM users;
-- 选择选择性接近full_selectivity的最小长度
```

---

## 四、索引优化技巧

### 4.1 避免函数操作

```sql
-- ❌ 错误：对索引列使用函数
EXPLAIN SELECT * FROM orders WHERE YEAR(created_at) = 2024;
-- type: ALL（全表扫描，无法使用created_at索引）

-- ✅ 正确：使用范围查询
EXPLAIN SELECT * FROM orders
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';
-- type: range（使用索引）

-- ❌ 错误：CONCAT函数
EXPLAIN SELECT * FROM users WHERE CONCAT(first_name, last_name) = 'Zhang San';
-- type: ALL

-- ✅ 正确：分别查询
EXPLAIN SELECT * FROM users WHERE first_name = 'Zhang' AND last_name = 'San';
-- type: ref
```

### 4.2 避免隐式类型转换

```sql
-- ❌ 错误：类型不匹配
-- 假设phone是VARCHAR类型
EXPLAIN SELECT * FROM users WHERE phone = 13800138000;  -- 数字
-- type: ALL（索引失效）

-- ✅ 正确：使用字符串
EXPLAIN SELECT * FROM users WHERE phone = '13800138000';
-- type: ref（使用索引）

-- ❌ 错误：id是BIGINT，但查询用字符串
EXPLAIN SELECT * FROM users WHERE id = '1';
-- MySQL会将'1'转换为1，可以使用索引（但不推荐）

-- ✅ 正确：类型匹配
EXPLAIN SELECT * FROM users WHERE id = 1;
```

### 4.3 优化LIKE查询

```sql
-- ❌ 错误：前导模糊查询
EXPLAIN SELECT * FROM users WHERE username LIKE '%san';
-- type: ALL（无法使用索引）

-- ❌ 错误：两端模糊查询
EXPLAIN SELECT * FROM users WHERE username LIKE '%san%';
-- type: ALL（无法使用索引）

-- ✅ 正确：前缀匹配
EXPLAIN SELECT * FROM users WHERE username LIKE 'zhang%';
-- type: range（使用索引）

-- 解决方案：使用全文索引
CREATE FULLTEXT INDEX ft_username ON users(username) WITH PARSER ngram;
EXPLAIN SELECT * FROM users WHERE MATCH(username) AGAINST('san' IN NATURAL LANGUAGE MODE);
-- 使用全文索引
```

### 4.4 优化OR查询

```sql
-- ❌ 错误：OR条件导致索引失效
EXPLAIN SELECT * FROM users WHERE username = 'zhangsan' OR email = 'zhangsan@example.com';
-- type: ALL或index_merge（性能差）

-- ✅ 正确：使用UNION
EXPLAIN
SELECT * FROM users WHERE username = 'zhangsan'
UNION
SELECT * FROM users WHERE email = 'zhangsan@example.com';
-- 两个查询都使用索引

-- ✅ 正确：如果OR的列都有索引，可以使用IN
EXPLAIN SELECT * FROM users WHERE status IN (1, 2);
-- type: range（使用索引）
```

### 4.5 优化ORDER BY

```sql
-- ❌ 错误：ORDER BY非索引列
EXPLAIN SELECT * FROM users ORDER BY nickname;
-- Extra: Using filesort（文件排序，慢）

-- ✅ 正确：ORDER BY索引列
EXPLAIN SELECT * FROM users ORDER BY created_at DESC;
-- Extra: 无filesort（使用索引）

-- ✅ 正确：WHERE + ORDER BY使用联合索引
CREATE INDEX idx_status_created ON users(status, created_at);
EXPLAIN SELECT * FROM users WHERE status = 1 ORDER BY created_at DESC;
-- Extra: Using index condition（使用索引）

-- ❌ 错误：ORDER BY顺序与索引不一致
CREATE INDEX idx_status_created ON users(status ASC, created_at DESC);
EXPLAIN SELECT * FROM users ORDER BY status DESC, created_at ASC;
-- Extra: Using filesort
```

---

## 五、常见索引错误

### 5.1 索引过多

```sql
-- ❌ 错误：为每个列都建索引
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    nickname VARCHAR(50) NOT NULL,
    status TINYINT UNSIGNED NOT NULL,

    -- 索引过多
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_nickname (nickname),
    INDEX idx_status (status),
    INDEX idx_created (created_at),
    INDEX idx_updated (updated_at)
);

-- ✅ 正确：只为常用查询条件建索引
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email),
    INDEX idx_status_created (status, created_at)  -- 联合索引
);
```

### 5.2 重复索引

```sql
-- ❌ 错误：重复索引
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_user_id_status ON orders(user_id, status);
-- idx_user_id是多余的（被idx_user_id_status包含）

-- ✅ 正确：删除重复索引
DROP INDEX idx_user_id ON orders;

-- 查找重复索引
SELECT
    table_name,
    index_name,
    GROUP_CONCAT(column_name ORDER BY seq_in_index) AS columns
FROM information_schema.STATISTICS
WHERE table_schema = 'your_database'
GROUP BY table_name, index_name
HAVING COUNT(*) > 1;
```

### 5.3 不必要的唯一索引

```sql
-- ❌ 错误：主键已经是唯一的，不需要额外唯一索引
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    UNIQUE KEY uniq_id (id)  -- 多余
);

-- ✅ 正确
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY
);
```

---

## 六、索引监控与维护

### 6.1 查看索引使用情况

```sql
-- 查看表的索引
SHOW INDEX FROM users;

-- 查看索引统计信息
SELECT
    table_name,
    index_name,
    seq_in_index,
    column_name,
    cardinality,
    index_type
FROM information_schema.STATISTICS
WHERE table_schema = 'your_database'
AND table_name = 'users';

-- 查看未使用的索引（MySQL 8.0+）
SELECT
    object_schema,
    object_name,
    index_name
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE index_name IS NOT NULL
AND index_name != 'PRIMARY'
AND count_star = 0
ORDER BY object_schema, object_name;
```

### 6.2 索引维护

```sql
-- 重建索引
ALTER TABLE users DROP INDEX idx_username, ADD INDEX idx_username (username);

-- 优化表（重建索引和表）
OPTIMIZE TABLE users;

-- 分析表（更新索引统计信息）
ANALYZE TABLE users;

-- 检查表
CHECK TABLE users;

-- 修复表
REPAIR TABLE users;
```

---

## 七、实战案例

### 案例1：订单查询优化

```sql
-- 需求：查询某用户的订单列表，按创建时间降序，分页

-- ❌ 原始查询（性能差）
SELECT * FROM orders
WHERE user_id = 123
ORDER BY created_at DESC
LIMIT 20 OFFSET 100;

-- 分析
EXPLAIN SELECT * FROM orders
WHERE user_id = 123
ORDER BY created_at DESC
LIMIT 20 OFFSET 100;
-- type: ALL或ref
-- Extra: Using filesort

-- ✅ 优化：创建联合索引
CREATE INDEX idx_user_created ON orders(user_id, created_at);

-- 优化后
EXPLAIN SELECT * FROM orders
WHERE user_id = 123
ORDER BY created_at DESC
LIMIT 20 OFFSET 100;
-- type: ref
-- Extra: Using index（覆盖索引）或无filesort
```

### 案例2：统计查询优化

```sql
-- 需求：统计每个状态的订单数

-- ❌ 原始查询
SELECT status, COUNT(*) FROM orders GROUP BY status;
-- 扫描全表

-- ✅ 优化：使用覆盖索引
CREATE INDEX idx_status ON orders(status);

EXPLAIN SELECT status, COUNT(*) FROM orders GROUP BY status;
-- Extra: Using index
```

### 案例3：范围查询优化

```sql
-- 需求：查询某时间段的订单

-- ❌ 原始查询
SELECT * FROM orders
WHERE DATE(created_at) = '2024-01-15';
-- 函数导致索引失效

-- ✅ 优化：使用范围查询
SELECT * FROM orders
WHERE created_at >= '2024-01-15 00:00:00'
AND created_at < '2024-01-16 00:00:00';
-- 使用created_at索引
```

---

## 八、本章总结

### 核心要点

1. **索引类型**：
   - 主键索引、唯一索引、普通索引
   - 联合索引、全文索引

2. **EXPLAIN分析**：
   - type：连接类型（const > eq_ref > ref > range > index > ALL）
   - Extra：额外信息（Using index > Using where > Using filesort）

3. **设计原则**：
   - 选择性原则
   - 最左前缀原则
   - 覆盖索引原则
   - 索引长度原则

4. **优化技巧**：
   - 避免函数操作
   - 避免隐式类型转换
   - 优化LIKE、OR、ORDER BY

5. **常见错误**：
   - 索引过多
   - 重复索引
   - 不必要的索引

### 下一步

完成本章学习后，你应该能够：
- ✅ 使用EXPLAIN分析查询
- ✅ 设计合理的索引
- ✅ 优化慢查询
- ✅ 避免常见索引错误

下一节：[20-查询优化实战](./20-查询优化实战.md)

# 18-数据分析查询

> 掌握各种数据分析场景的SQL实现

---

## 📖 本章目标

- 掌握用户行为分析
- 掌握商品销售分析
- 掌握订单转化分析
- 掌握用户价值分析
- 掌握漏斗分析
- 掌握同期群分析

---

## 一、用户行为分析

### 1.1 用户活跃度分析

```sql
-- DAU（日活跃用户数）
SELECT
    DATE(login_at) AS date,
    COUNT(DISTINCT user_id) AS dau
FROM login_logs
WHERE login_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
GROUP BY DATE(login_at)
ORDER BY date;

-- WAU（周活跃用户数）
SELECT
    YEARWEEK(login_at) AS week,
    COUNT(DISTINCT user_id) AS wau
FROM login_logs
WHERE login_at >= DATE_SUB(NOW(), INTERVAL 12 WEEK)
GROUP BY YEARWEEK(login_at)
ORDER BY week;

-- MAU（月活跃用户数）
SELECT
    DATE_FORMAT(login_at, '%Y-%m') AS month,
    COUNT(DISTINCT user_id) AS mau
FROM login_logs
WHERE login_at >= DATE_SUB(NOW(), INTERVAL 12 MONTH)
GROUP BY DATE_FORMAT(login_at, '%Y-%m')
ORDER BY month;

-- 活跃度分布
SELECT
    CASE
        WHEN login_days >= 25 THEN '高度活跃'
        WHEN login_days >= 15 THEN '中度活跃'
        WHEN login_days >= 5 THEN '低度活跃'
        ELSE '不活跃'
    END AS activity_level,
    COUNT(*) AS user_count
FROM (
    SELECT
        user_id,
        COUNT(DISTINCT DATE(login_at)) AS login_days
    FROM login_logs
    WHERE login_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
    GROUP BY user_id
) AS t
GROUP BY activity_level;
```

### 1.2 用户留存分析

```sql
-- 次日留存率
WITH first_login AS (
    SELECT user_id, MIN(DATE(created_at)) AS first_day
    FROM users
    WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
    GROUP BY user_id
)
SELECT
    fl.first_day,
    COUNT(DISTINCT fl.user_id) AS new_users,
    COUNT(DISTINCT CASE
        WHEN EXISTS (
            SELECT 1 FROM login_logs ll
            WHERE ll.user_id = fl.user_id
            AND DATE(ll.login_at) = DATE_ADD(fl.first_day, INTERVAL 1 DAY)
        ) THEN fl.user_id
    END) AS day1_retained,
    ROUND(
        COUNT(DISTINCT CASE
            WHEN EXISTS (
                SELECT 1 FROM login_logs ll
                WHERE ll.user_id = fl.user_id
                AND DATE(ll.login_at) = DATE_ADD(fl.first_day, INTERVAL 1 DAY)
            ) THEN fl.user_id
        END) * 100.0 / COUNT(DISTINCT fl.user_id),
        2
    ) AS day1_retention_rate
FROM first_login fl
GROUP BY fl.first_day
ORDER BY fl.first_day DESC;

-- 7日留存率
SELECT
    fl.first_day,
    COUNT(DISTINCT fl.user_id) AS new_users,
    COUNT(DISTINCT CASE
        WHEN EXISTS (
            SELECT 1 FROM login_logs ll
            WHERE ll.user_id = fl.user_id
            AND DATE(ll.login_at) = DATE_ADD(fl.first_day, INTERVAL 7 DAY)
        ) THEN fl.user_id
    END) AS day7_retained,
    ROUND(
        COUNT(DISTINCT CASE
            WHEN EXISTS (
                SELECT 1 FROM login_logs ll
                WHERE ll.user_id = fl.user_id
                AND DATE(ll.login_at) = DATE_ADD(fl.first_day, INTERVAL 7 DAY)
            ) THEN fl.user_id
        END) * 100.0 / COUNT(DISTINCT fl.user_id),
        2
    ) AS day7_retention_rate
FROM first_login fl
GROUP BY fl.first_day
ORDER BY fl.first_day DESC;

-- N日留存率（通用）
SELECT
    DATE_ADD(first_day, INTERVAL days DAY) AS check_day,
    COUNT(DISTINCT user_id) AS retained_users
FROM first_login
CROSS JOIN (SELECT 1 AS days UNION SELECT 3 UNION SELECT 7 UNION SELECT 14 UNION SELECT 30) AS d
WHERE EXISTS (
    SELECT 1 FROM login_logs ll
    WHERE ll.user_id = first_login.user_id
    AND DATE(ll.login_at) = DATE_ADD(first_login.first_day, INTERVAL d.days DAY)
)
GROUP BY check_day, days
ORDER BY check_day, days;
```

---

## 二、商品销售分析

### 2.1 商品销售排行

```sql
-- 商品销量Top 100
SELECT
    p.id,
    p.name,
    c.name AS category_name,
    IFNULL(SUM(oi.quantity), 0) AS total_sales,
    IFNULL(SUM(oi.subtotal), 0) / 100 AS total_revenue,
    COUNT(DISTINCT oi.order_id) AS order_count,
    IFNULL(AVG(oi.price_cents), 0) / 100 AS avg_price
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status IN (2, 3, 4)
WHERE p.deleted_at IS NULL
GROUP BY p.id, p.name, c.name
ORDER BY total_sales DESC
LIMIT 100;

-- 按分类的销售排行
SELECT
    c.name AS category_name,
    COUNT(DISTINCT p.id) AS product_count,
    IFNULL(SUM(oi.quantity), 0) AS total_sales,
    IFNULL(SUM(oi.subtotal), 0) / 100 AS total_revenue
FROM categories c
LEFT JOIN products p ON c.id = p.category_id
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status IN (2, 3, 4)
GROUP BY c.id, c.name
ORDER BY total_revenue DESC;

-- 商品销售趋势（最近30天）
SELECT
    DATE(o.created_at) AS date,
    p.name AS product_name,
    SUM(oi.quantity) AS daily_sales
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
JOIN products p ON oi.product_id = p.id
WHERE o.created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
AND o.status IN (2, 3, 4)
AND p.id = :product_id
GROUP BY DATE(o.created_at), p.name
ORDER BY date;
```

### 2.2 库存周转分析

```sql
-- 库存周转率 = 销售数量 / 平均库存
SELECT
    p.id,
    p.name,
    p.stock AS current_stock,
    IFNULL(SUM(oi.quantity), 0) AS total_sales,
    ROUND(
        IFNULL(SUM(oi.quantity), 0) / NULLIF((p.stock + IFNULL(SUM(oi.quantity), 0)) / 2, 0),
        2
    ) AS turnover_rate,
    CASE
        WHEN p.stock = 0 THEN '缺货'
        WHEN IFNULL(SUM(oi.quantity), 0) / NULLIF((p.stock + IFNULL(SUM(oi.quantity), 0)) / 2, 0) > 10 THEN '畅销'
        WHEN IFNULL(SUM(oi.quantity), 0) / NULLIF((p.stock + IFNULL(SUM(oi.quantity), 0)) / 2, 0) > 5 THEN '正常'
        ELSE '滞销'
    END AS status
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id
    AND o.status IN (2, 3, 4)
    AND o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
WHERE p.deleted_at IS NULL
GROUP BY p.id, p.name, p.stock
ORDER BY turnover_rate DESC;
```

---

## 三、订单转化分析

### 3.1 订单转化漏斗

```sql
-- 下单 → 支付 → 发货 → 完成 转化漏斗
SELECT
    COUNT(*) AS created_orders,
    SUM(CASE WHEN status >= 2 THEN 1 ELSE 0 END) AS paid_orders,
    SUM(CASE WHEN status >= 3 THEN 1 ELSE 0 END) AS shipped_orders,
    SUM(CASE WHEN status = 4 THEN 1 ELSE 0 END) AS completed_orders,

    ROUND(SUM(CASE WHEN status >= 2 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS payment_rate,
    ROUND(SUM(CASE WHEN status >= 3 THEN 1 ELSE 0 END) * 100.0 / NULLIF(SUM(CASE WHEN status >= 2 THEN 1 ELSE 0 END), 0), 2) AS shipment_rate,
    ROUND(SUM(CASE WHEN status = 4 THEN 1 ELSE 0 END) * 100.0 / NULLIF(SUM(CASE WHEN status >= 3 THEN 1 ELSE 0 END), 0), 2) AS completion_rate
FROM orders
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
AND deleted_at IS NULL;

-- 按天的转化率趋势
SELECT
    DATE(created_at) AS date,
    COUNT(*) AS created_orders,
    SUM(CASE WHEN status >= 2 THEN 1 ELSE 0 END) AS paid_orders,
    ROUND(SUM(CASE WHEN status >= 2 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS payment_rate
FROM orders
WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
AND deleted_at IS NULL
GROUP BY DATE(created_at)
ORDER BY date;
```

### 3.2 取消订单分析

```sql
-- 取消订单统计
SELECT
    status,
    CASE status
        WHEN 1 THEN '待支付'
        WHEN 5 THEN '已取消'
    END AS status_text,
    COUNT(*) AS order_count,
    SUM(total_amount) / 100 AS total_amount,
    AVG(TIMESTAMPDIFF(MINUTE, created_at, cancelled_at)) AS avg_cancel_minutes
FROM orders
WHERE status IN (1, 5)
AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY status;

-- 取消原因分析（需要额外的取消原因字段）
SELECT
    cancel_reason,
    COUNT(*) AS count,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders WHERE status = 5 AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)), 2) AS percentage
FROM orders
WHERE status = 5
AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY cancel_reason
ORDER BY count DESC;
```

---

## 四、用户价值分析（RFM模型）

### 4.1 RFM分层

```sql
-- RFM模型分析
WITH user_rfm AS (
    SELECT
        user_id,
        DATEDIFF(CURDATE(), MAX(created_at)) AS recency,  -- 最近一次消费距今天数
        COUNT(*) AS frequency,  -- 消费频率
        SUM(total_amount) / 100 AS monetary  -- 消费金额
    FROM orders
    WHERE status IN (2, 3, 4)
    AND deleted_at IS NULL
    GROUP BY user_id
),
rfm_score AS (
    SELECT
        user_id,
        recency,
        frequency,
        monetary,
        -- 分数越高越好（R分数相反，天数越小越好）
        NTILE(5) OVER (ORDER BY recency) AS r_score,  -- 1-5分
        NTILE(5) OVER (ORDER BY frequency DESC) AS f_score,
        NTILE(5) OVER (ORDER BY monetary DESC) AS m_score
    FROM user_rfm
)
SELECT
    user_id,
    recency,
    frequency,
    monetary,
    r_score,
    f_score,
    m_score,
    (5 - r_score + 1) + f_score + m_score AS rfm_total,  -- RFM总分
    CASE
        WHEN (5 - r_score + 1) >= 4 AND f_score >= 4 AND m_score >= 4 THEN '重要价值客户'
        WHEN (5 - r_score + 1) >= 4 AND f_score >= 3 THEN '重要发展客户'
        WHEN (5 - r_score + 1) >= 3 AND f_score >= 3 AND m_score >= 3 THEN '重要保持客户'
        WHEN (5 - r_score + 1) <= 2 AND f_score >= 3 THEN '重要挽留客户'
        WHEN (5 - r_score + 1) >= 4 AND f_score <= 2 THEN '一般发展客户'
        WHEN (5 - r_score + 1) >= 3 AND f_score <= 2 THEN '一般保持客户'
        WHEN (5 - r_score + 1) <= 2 AND f_score <= 2 AND m_score >= 3 THEN '一般挽留客户'
        ELSE '一般客户'
    END AS user_type
FROM rfm_score
ORDER BY rfm_total DESC;

-- RFM分布统计
SELECT
    user_type,
    COUNT(*) AS user_count,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM rfm_score), 2) AS percentage,
    ROUND(AVG(monetary), 2) AS avg_monetary
FROM (
    SELECT
        user_id,
        monetary,
        r_score,
        f_score,
        m_score,
        CASE
            WHEN (5 - r_score + 1) >= 4 AND f_score >= 4 AND m_score >= 4 THEN '重要价值客户'
            WHEN (5 - r_score + 1) >= 4 AND f_score >= 3 THEN '重要发展客户'
            WHEN (5 - r_score + 1) >= 3 AND f_score >= 3 AND m_score >= 3 THEN '重要保持客户'
            WHEN (5 - r_score + 1) <= 2 AND f_score >= 3 THEN '重要挽留客户'
            ELSE '其他客户'
        END AS user_type
    FROM rfm_score
) AS t
GROUP BY user_type
ORDER BY user_count DESC;
```

### 4.2 用户生命周期价值（LTV）

```sql
-- 用户生命周期价值 = 平均订单金额 × 购买频率 × 用户生命周期
SELECT
    u.id,
    u.username,
    COUNT(o.id) AS order_count,
    IFNULL(SUM(o.total_amount), 0) / 100 AS total_spent,
    IFNULL(AVG(o.total_amount), 0) / 100 AS avg_order_amount,
    DATEDIFF(CURDATE(), u.created_at) AS lifetime_days,
    ROUND(
        (IFNULL(SUM(o.total_amount), 0) / 100) /
        NULLIF(DATEDIFF(CURDATE(), u.created_at) / 30, 0),  -- 月均消费
        2
    ) AS monthly_revenue,
    ROUND(
        (IFNULL(SUM(o.total_amount), 0) / 100) /
        NULLIF(DATEDIFF(CURDATE(), u.created_at) / 30, 0) * 12,  -- 预估年度价值
        2
    ) AS estimated_ltv
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status IN (2, 3, 4)
WHERE u.deleted_at IS NULL
GROUP BY u.id, u.username, u.created_at
HAVING order_count > 0
ORDER BY estimated_ltv DESC
LIMIT 100;
```

---

## 五、同期群分析（Cohort Analysis）

### 5.1 按注册月份的用户留存

```sql
-- 按注册月份分组，分析各月用户的留存情况
WITH user_cohort AS (
    SELECT
        user_id,
        DATE_FORMAT(created_at, '%Y-%m') AS cohort_month
    FROM users
    WHERE created_at >= DATE_SUB(NOW(), INTERVAL 12 MONTH)
),
user_activity AS (
    SELECT
        uc.cohort_month,
        DATE_FORMAT(ll.login_at, '%Y-%m') AS activity_month,
        COUNT(DISTINCT ll.user_id) AS active_users
    FROM user_cohort uc
    JOIN login_logs ll ON uc.user_id = ll.user_id
    WHERE ll.login_at >= uc.cohort_month
    GROUP BY uc.cohort_month, DATE_FORMAT(ll.login_at, '%Y-%m')
),
cohort_size AS (
    SELECT
        cohort_month,
        COUNT(DISTINCT user_id) AS cohort_users
    FROM user_cohort
    GROUP BY cohort_month
)
SELECT
    ua.cohort_month,
    ua.activity_month,
    PERIOD_DIFF(
        CAST(REPLACE(ua.activity_month, '-', '') AS UNSIGNED),
        CAST(REPLACE(ua.cohort_month, '-', '') AS UNSIGNED)
    ) AS month_number,
    cs.cohort_users,
    ua.active_users,
    ROUND(ua.active_users * 100.0 / cs.cohort_users, 2) AS retention_rate
FROM user_activity ua
JOIN cohort_size cs ON ua.cohort_month = cs.cohort_month
ORDER BY ua.cohort_month, month_number;
```

---

## 六、漏斗分析

### 6.1 购买漏斗

```sql
-- 浏览 → 加入购物车 → 下单 → 支付
WITH funnel AS (
    SELECT
        COUNT(DISTINCT bl.user_id) AS browse_users,
        COUNT(DISTINCT CASE WHEN EXISTS (
            SELECT 1 FROM cart_items ci WHERE ci.user_id = bl.user_id
        ) THEN bl.user_id END) AS cart_users,
        COUNT(DISTINCT CASE WHEN EXISTS (
            SELECT 1 FROM orders o WHERE o.user_id = bl.user_id
        ) THEN bl.user_id END) AS order_users,
        COUNT(DISTINCT CASE WHEN EXISTS (
            SELECT 1 FROM orders o WHERE o.user_id = bl.user_id AND o.status >= 2
        ) THEN bl.user_id END) AS paid_users
    FROM browse_logs bl
    WHERE bl.created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)
)
SELECT
    '浏览' AS step,
    browse_users AS users,
    100.00 AS conversion_rate
FROM funnel

UNION ALL

SELECT
    '加入购物车' AS step,
    cart_users AS users,
    ROUND(cart_users * 100.0 / browse_users, 2) AS conversion_rate
FROM funnel

UNION ALL

SELECT
    '下单' AS step,
    order_users AS users,
    ROUND(order_users * 100.0 / cart_users, 2) AS conversion_rate
FROM funnel

UNION ALL

SELECT
    '支付' AS step,
    paid_users AS users,
    ROUND(paid_users * 100.0 / order_users, 2) AS conversion_rate
FROM funnel;
```

---

## 七、时间分析

### 7.1 订单时间分布

```sql
-- 按小时分布
SELECT
    HOUR(created_at) AS hour,
    COUNT(*) AS order_count,
    SUM(CASE WHEN status >= 2 THEN 1 ELSE 0 END) AS paid_count,
    SUM(CASE WHEN status >= 2 THEN total_amount ELSE 0 END) / 100 AS total_sales
FROM orders
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY HOUR(created_at)
ORDER BY hour;

-- 按星期几分布
SELECT
    DAYOFWEEK(created_at) AS day_of_week,
    CASE DAYOFWEEK(created_at)
        WHEN 1 THEN '周日'
        WHEN 2 THEN '周一'
        WHEN 3 THEN '周二'
        WHEN 4 THEN '周三'
        WHEN 5 THEN '周四'
        WHEN 6 THEN '周五'
        WHEN 7 THEN '周六'
    END AS day_name,
    COUNT(*) AS order_count,
    SUM(CASE WHEN status >= 2 THEN total_amount ELSE 0 END) / 100 AS total_sales
FROM orders
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY DAYOFWEEK(created_at)
ORDER BY day_of_week;
```

---

## 八、本章总结

### 核心要点

1. **用户行为分析**：
   - DAU/WAU/MAU
   - 用户留存
   - 活跃度分布

2. **商品销售分析**：
   - 销售排行
   - 库存周转
   - 销售趋势

3. **订单转化分析**：
   - 转化漏斗
   - 取消订单分析

4. **用户价值分析**：
   - RFM模型
   - 用户分层
   - LTV计算

5. **高级分析**：
   - 同期群分析
   - 漏斗分析
   - 时间分布分析

### 下一步

完成本章学习后，你应该能够：
- ✅ 分析用户行为数据
- ✅ 分析商品销售情况
- ✅ 分析订单转化率
- ✅ 进行用户价值评估
- ✅ 实现高级数据分析

**🎉 恭喜完成第四章！**

下一章：[第五章 - 性能优化](./19-索引优化实战.md)

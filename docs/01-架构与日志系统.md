# 01-架构与日志系统

> 对应课程：第01-02讲
> 学习时间：2-3小时
> 前置要求：已完成MySQL环境搭建（见00-环境准备.md）

---

## 第01讲：基础架构 - 一条SQL查询语句是如何执行的？

### 核心知识点

**MySQL架构分层**：
```
┌─────────────────────────────────────────┐
│  Server 层                              │
│  ├─ 连接器（管理连接、权限验证）         │
│  ├─ 查询缓存（8.0已移除）               │
│  ├─ 分析器（词法分析、语法分析）         │
│  ├─ 优化器（执行计划生成、索引选择）     │
│  └─ 执行器（操作引擎、返回结果）         │
├─────────────────────────────────────────┤
│  存储引擎层（InnoDB、MyISAM等）          │
└─────────────────────────────────────────┘
```

**SQL执行流程**（查询语句）：
1. **连接器**：建立连接、验证权限
2. **查询缓存**：检查缓存（命中则直接返回）
3. **分析器**：词法分析 → 语法分析
4. **优化器**：生成执行计划、选择索引
5. **执行器**：调用存储引擎接口、返回结果

### 实操练习

#### 1. 连接MySQL并查看连接信息

```sql
-- 查看当前连接
SHOW PROCESSLIST;

-- 查看连接超时时间（默认8小时 = 28800秒）
SHOW VARIABLES LIKE 'wait_timeout';

-- 查看当前用户
SELECT USER();

-- 查看当前数据库
SELECT DATABASE();
```

#### 2. 创建测试表并插入数据

```sql
-- 创建数据库
CREATE DATABASE IF NOT EXISTS mysql_study DEFAULT CHARACTER SET utf8mb4;
USE mysql_study;

-- 创建用户表
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    age INT,
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- 插入测试数据
INSERT INTO users (name, age, email) VALUES
('张三', 25, 'zhangsan@example.com'),
('李四', 30, 'lisi@example.com'),
('王五', 28, 'wangwu@example.com'),
('赵六', 35, 'zhaoliu@example.com');
```

#### 3. 观察查询缓存（MySQL 5.7）

```sql
-- 查看查询缓存配置（MySQL 8.0已移除此功能）
SHOW VARIABLES LIKE 'query_cache%';

-- 执行相同查询两次，观察执行时间
SELECT * FROM users WHERE age > 25;
SELECT * FROM users WHERE age > 25;

-- 注意：MySQL 8.0移除了查询缓存，因为缓存失效频繁，收益不大
```

#### 4. 分析器演示

```sql
-- 正常查询（分析器通过）
SELECT * FROM users WHERE name = '张三';

-- 语法错误（分析器报错）
SELEC * FROM users;  -- 拼写错误
-- ERROR 1064: You have an error in your SQL syntax

SELECT * FROM user;   -- 表名错误
-- ERROR 1146: Table 'mysql_study.user' doesn't exist
```

#### 5. 优化器演示

```sql
-- 创建索引
CREATE INDEX idx_age ON users(age);
CREATE INDEX idx_name ON users(name);

-- 查看执行计划（优化器的选择结果）
EXPLAIN SELECT * FROM users WHERE age = 25;
EXPLAIN SELECT * FROM users WHERE name = '张三';

-- 多表join时，优化器决定表的连接顺序
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    amount DECIMAL(10,2),
    order_date DATE
) ENGINE=InnoDB;

INSERT INTO orders (user_id, amount, order_date) VALUES
(1, 100.00, '2024-01-01'),
(2, 200.00, '2024-01-02'),
(1, 150.00, '2024-01-03');

-- 优化器会选择合适的join顺序
EXPLAIN SELECT u.name, o.amount
FROM users u JOIN orders o ON u.id = o.user_id
WHERE u.age > 25;
```

#### 6. 执行器演示

> **注意**：本段代码仅用于演示执行器权限检查的概念，**可跳过实际执行**。
>
> MySQL 8.0+ 中，GRANT 语法已改变，不能直接创建用户，需要先用 `CREATE USER` 创建用户再授权。
> 理解执行器会做权限检查即可，无需实际操作。

```sql
-- 查看执行器权限检查（仅概念演示，可跳过）
-- 假设当前用户没有users表的SELECT权限
REVOKE SELECT ON mysql_study.users FROM 'test_user'@'localhost';
-- 执行器会报错：SELECT command denied

-- 重新授权
GRANT SELECT ON mysql_study.users TO 'test_user'@'localhost';
```

---

## 第02讲：日志系统 - 一条SQL更新语句是如何执行的？

### 核心知识点

**两种重要日志**：

1. **redo log（重做日志）**
   - 属于：InnoDB引擎特有
   - 作用：保证crash-safe能力
   - 机制：WAL（Write-Ahead Logging）先写日志，再写磁盘
   - 特点：循环写，固定大小（如4个1GB文件）

2. **binlog（归档日志）**
   - 属于：Server层
   - 作用：用于备份恢复、主从复制
   - 格式：statement/row/mixed
   - 特点：追加写，不会覆盖

**redo log vs binlog 对比**：

| 特性 | redo log | binlog |
|------|----------|--------|
| 层次 | InnoDB引擎层 | Server层 |
| 写入方式 | 循环写（覆盖） | 追加写（不覆盖） |
| 内容 | 物理日志（数据页修改） | 逻辑日志（SQL语句） |
| 作用 | crash-safe | 备份恢复、主从复制 |

**两阶段提交**：
```
1. 执行器调用引擎接口写数据
2. InnoDB写redo log，状态：prepare
3. 执行器写binlog
4. InnoDB提交事务，redo log状态：commit
```

**为什么需要两阶段提交？**
保证redo log和binlog的一致性，避免主从数据不一致。

### 实操练习

#### 1. 查看日志配置

```sql
-- 查看redo log配置
SHOW VARIABLES LIKE 'innodb_log%';

-- 查看binlog配置
SHOW VARIABLES LIKE 'log_bin%';
SHOW VARIABLES LIKE 'binlog%';

-- 查看binlog格式
SHOW VARIABLES LIKE 'binlog_format';
-- ROW: 记录每行数据变化（推荐）
-- STATEMENT: 记录SQL语句
-- MIXED: 混合模式
```

#### 2. 执行更新语句并观察日志

```sql
-- 更新语句
UPDATE users SET age = 26 WHERE id = 1;

-- 查看binlog是否开启
SHOW VARIABLES LIKE 'log_bin';

-- 查看binlog文件列表
SHOW BINARY LOGS;

-- 查看当前使用的binlog文件
SHOW MASTER STATUS;

-- 查看binlog内容（需要使用mysqlbinlog工具）
-- 在命令行执行：
-- mysqlbinlog /var/lib/mysql/binlog.000001
```

#### 3. 模拟crash-safe演示

```sql
-- 创建测试表
CREATE TABLE account (
    id INT PRIMARY KEY,
    balance DECIMAL(10,2)
) ENGINE=InnoDB;

INSERT INTO account VALUES (1, 1000.00), (2, 1000.00);

-- 开启事务进行转账
START TRANSACTION;
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 查看结果
SELECT * FROM account;

-- 即使MySQL异常重启，由于有redo log，数据也不会丢失
-- redo log保证了已提交的事务持久化
```

#### 4. 观察WAL机制

```sql
-- 查看InnoDB缓冲池配置
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';

-- 查看脏页刷新策略
SHOW VARIABLES LIKE 'innodb_flush%';

-- innodb_flush_log_at_trx_commit 参数：
-- 0: 每秒写入并刷盘（性能最好，可能丢1秒数据）
-- 1: 每次事务提交都刷盘（最安全，默认值）
-- 2: 每次事务提交写入OS cache，每秒刷盘

SHOW VARIABLES LIKE 'innodb_flush_log_at_trx_commit';
```

#### 5. binlog格式对比

```sql
-- 设置为STATEMENT格式
SET binlog_format = 'STATEMENT';

-- 执行更新
UPDATE users SET age = age + 1 WHERE id = 1;
-- binlog记录：UPDATE users SET age = age + 1 WHERE id = 1;

-- 设置为ROW格式
SET binlog_format = 'ROW';

-- 执行更新
UPDATE users SET age = age + 1 WHERE id = 1;
-- binlog记录：具体的行变化（before: age=26, after: age=27）

-- 注意：修改binlog_format需要相应权限，生产环境建议使用ROW格式
```

#### 6. 两阶段提交验证

```sql
-- 查看事务提交日志
SHOW ENGINE INNODB STATUS\G

-- 在大量更新时，可以看到prepare和commit的过程
START TRANSACTION;
UPDATE users SET age = age + 1;
-- 此时redo log处于prepare状态
COMMIT;
-- commit后，redo log和binlog都已写入
```

---

## 重点总结

### 第01讲要点

1. **架构分层**：Server层（连接、分析、优化、执行） + 存储引擎层
2. **执行流程**：连接器 → 查询缓存 → 分析器 → 优化器 → 执行器 → 存储引擎
3. **查询缓存**：MySQL 8.0已移除（失效频繁，收益低）
4. **执行器**：负责权限检查、调用存储引擎接口

### 第02讲要点

1. **redo log**：InnoDB特有，循环写，保证crash-safe，WAL机制
2. **binlog**：Server层，追加写，用于备份和主从复制
3. **两阶段提交**：保证redo log和binlog一致性
4. **binlog格式**：ROW格式更安全（推荐），STATEMENT格式更节省空间

---

## 课后思考

1. 为什么MySQL 8.0移除了查询缓存？
   - 提示：考虑缓存失效的场景

2. 如果只有redo log没有binlog会怎样？
   - 提示：考虑主从复制场景

3. 两阶段提交中，如果在prepare阶段crash怎么办？在commit阶段crash怎么办？
   - 提示：MySQL如何恢复数据

4. 为什么redo log采用循环写，而binlog采用追加写？
   - 提示：考虑两者的不同用途

---

## 下一步

完成本讲后，继续学习：
- **02-事务隔离.md**：理解MySQL的事务隔离级别和MVCC机制

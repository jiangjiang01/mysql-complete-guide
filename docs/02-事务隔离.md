# 02-事务隔离

> 对应课程:第03讲
> 学习时间：1-2小时
> 前置要求：已完成01-架构与日志系统学习

---

## 第03讲：事务隔离 - 为什么你改了我还看不见？

### 核心知识点

**事务的ACID特性**：
- **A**tomicity（原子性）：事务中的操作要么全部完成，要么全部不完成
- **C**onsistency（一致性）：事务前后数据保持一致
- **I**solation（隔离性）：多个事务并发执行时相互隔离
- **D**urability（持久性）：事务提交后，修改永久保存

**四种隔离级别**（从低到高）：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 说明 |
|---------|------|-----------|------|------|
| READ UNCOMMITTED<br>读未提交 | ✓ | ✓ | ✓ | 可读取未提交数据 |
| READ COMMITTED<br>读已提交 | ✗ | ✓ | ✓ | 只能读已提交数据<br>Oracle默认 |
| REPEATABLE READ<br>可重复读 | ✗ | ✗ | ✓ | 同一事务内读取一致<br>**MySQL默认** |
| SERIALIZABLE<br>串行化 | ✗ | ✗ | ✗ | 完全串行执行 |

**关键概念**：
- **脏读**：读到其他事务未提交的数据
- **不可重复读**：同一事务内，两次读取同一行数据结果不同
- **幻读**：同一事务内，两次查询返回的行数不同

**MVCC（多版本并发控制）**：
- InnoDB通过为每行记录添加两个隐藏列实现：
  - `trx_id`：事务ID
  - `roll_pointer`：回滚指针，指向undo log
- 通过读取历史版本实现快照读，避免加锁

**一致性读视图（Read View）**：
- 在REPEATABLE READ级别，事务启动时创建Read View
- 事务内所有查询都基于该Read View，保证可重复读

### 实操练习

#### 1. 查看和设置隔离级别

```sql
-- 查看当前会话隔离级别
SELECT @@transaction_isolation;
-- 或（旧语法）
SELECT @@tx_isolation;

-- 查看全局隔离级别
SELECT @@global.transaction_isolation;

-- 设置当前会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 恢复默认（REPEATABLE READ）
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

#### 2. 准备测试数据

```sql
USE mysql_study;

-- 创建测试表
CREATE TABLE account (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    balance DECIMAL(10,2)
) ENGINE=InnoDB;

INSERT INTO account VALUES
(1, '张三', 1000.00),
(2, '李四', 2000.00);

SELECT * FROM account;
```

#### 3. 演示脏读（READ UNCOMMITTED）

**打开两个MySQL客户端窗口**：

```sql
-- === 窗口A ===
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

START TRANSACTION;
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 1000.00

-- 等待窗口B执行...

-- 再次查询
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 500.00（脏读！读到了未提交的数据）
```

```sql
-- === 窗口B ===
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

START TRANSACTION;
UPDATE account SET balance = 500 WHERE id = 1;
-- 不要COMMIT

-- 让窗口A查询...

-- 回滚事务
ROLLBACK;
```

**结论**：窗口A读到了窗口B未提交的数据（脏读）。

#### 4. 演示不可重复读（READ COMMITTED）

```sql
-- === 窗口A ===
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

START TRANSACTION;
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 1000.00

-- 等待窗口B提交...

-- 再次查询
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 500.00（不可重复读！同一事务内读到了不同的值）

COMMIT;
```

```sql
-- === 窗口B ===
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

START TRANSACTION;
UPDATE account SET balance = 500 WHERE id = 1;
COMMIT;  -- 提交事务
```

**结论**：窗口A在同一事务内，两次查询结果不同（不可重复读）。

#### 5. 演示可重复读（REPEATABLE READ - MySQL默认）

```sql
-- === 窗口A ===
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

START TRANSACTION;
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 500.00

-- 等待窗口B提交...

-- 再次查询
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 500.00（可重复读！）

COMMIT;

-- 提交后再查询
SELECT * FROM account WHERE id = 1;
-- 结果：balance = 800.00（读到最新数据）
```

```sql
-- === 窗口B ===
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

START TRANSACTION;
UPDATE account SET balance = 800 WHERE id = 1;
COMMIT;
```

**结论**：窗口A在事务内始终读到一致的数据，提交后才能看到其他事务的修改。

#### 6. 演示幻读（REPEATABLE READ部分解决）

```sql
-- === 窗口A ===
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

START TRANSACTION;
-- 查询所有账户
SELECT * FROM account;
-- 结果：2条记录（id=1和id=2）

-- 等待窗口B插入数据...

-- 再次查询
SELECT * FROM account;
-- 结果：还是2条记录（快照读，看不到新插入的数据）

-- 但是如果尝试插入相同的id
INSERT INTO account VALUES (3, '王五', 1500.00);
-- 错误！因为id=3已经存在（当前读会看到）

-- 或者使用当前读
SELECT * FROM account FOR UPDATE;
-- 结果：3条记录（当前读，能看到新数据）

COMMIT;
```

```sql
-- === 窗口B ===
START TRANSACTION;
INSERT INTO account VALUES (3, '王五', 1500.00);
COMMIT;
```

**说明**：
- **快照读**（普通SELECT）：使用MVCC，看不到其他事务的插入
- **当前读**（SELECT ... FOR UPDATE / INSERT / UPDATE / DELETE）：读取最新版本，会加锁

#### 7. 演示串行化（SERIALIZABLE）

```sql
-- === 窗口A ===
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

START TRANSACTION;
SELECT * FROM account WHERE id = 1;
-- 会对读取的行加共享锁

-- 等待窗口B...
```

```sql
-- === 窗口B ===
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

START TRANSACTION;
UPDATE account SET balance = 1000 WHERE id = 1;
-- 阻塞！等待窗口A释放锁...

-- 窗口A执行COMMIT后，窗口B才能继续
```

**结论**：SERIALIZABLE完全串行化执行，性能最差，但隔离性最强。

#### 8. MVCC原理演示

```sql
-- 查看InnoDB行格式（包含隐藏列）
-- 创建测试表
CREATE TABLE mvcc_test (
    id INT PRIMARY KEY,
    value INT
) ENGINE=InnoDB;

INSERT INTO mvcc_test VALUES (1, 100);

-- 查看事务ID
START TRANSACTION;
SELECT * FROM mvcc_test WHERE id = 1;
SELECT TRX_ID FROM INFORMATION_SCHEMA.INNODB_TRX
WHERE TRX_MYSQL_THREAD_ID = CONNECTION_ID();
-- 记下事务ID

COMMIT;

-- MVCC通过trx_id和roll_pointer实现多版本
-- 每个事务看到的是一致性视图（Read View）
```

#### 9. 事务启动方式对比

```sql
-- 方式1：显式启动事务（推荐）
START TRANSACTION;  -- 或 BEGIN
-- 执行SQL...
COMMIT;  -- 或 ROLLBACK

-- 方式2：START TRANSACTION WITH CONSISTENT SNAPSHOT
-- 立即创建一致性视图（REPEATABLE READ下）
START TRANSACTION WITH CONSISTENT SNAPSHOT;
-- 执行SQL...
COMMIT;

-- 方式3：SET autocommit=0（不推荐）
SET autocommit = 0;
-- 每条SQL自动开启事务，需手动COMMIT
-- 容易导致长事务
```

**注意**：
- 在REPEATABLE READ级别：
  - `START TRANSACTION`：第一条SELECT时创建Read View
  - `START TRANSACTION WITH CONSISTENT SNAPSHOT`：立即创建Read View

#### 10. 长事务的危害

```sql
-- 查看当前运行的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;

-- 查看长事务（运行超过60秒）
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX
WHERE TIME_TO_SEC(TIMEDIFF(NOW(), TRX_STARTED)) > 60;

-- 长事务的危害：
-- 1. 占用锁资源，可能阻塞其他事务
-- 2. 占用undo log空间，影响性能
-- 3. 可能导致主从延迟

-- 如何避免长事务：
-- 1. 使用SET autocommit=1（默认）
-- 2. 及时提交事务
-- 3. 使用SET SESSION MAX_EXECUTION_TIME设置超时
SET SESSION MAX_EXECUTION_TIME = 30000;  -- 30秒超时
```

---

## 重点总结

1. **MySQL默认隔离级别**：REPEATABLE READ（可重复读）

2. **四种隔离级别**：
   - READ UNCOMMITTED：最低，有脏读问题
   - READ COMMITTED：Oracle默认，有不可重复读问题
   - REPEATABLE READ：MySQL默认，通过MVCC避免不可重复读
   - SERIALIZABLE：最高，完全串行化

3. **MVCC机制**：
   - 通过trx_id和roll_pointer实现多版本
   - Read View保证一致性读
   - 快照读vs当前读

4. **事务启动**：
   - 推荐：`START TRANSACTION` + `COMMIT`
   - REPEATABLE READ下可用：`START TRANSACTION WITH CONSISTENT SNAPSHOT`
   - 避免：`SET autocommit=0`（容易长事务）

5. **长事务危害**：
   - 占用锁资源
   - 占用undo log空间
   - 可能影响主从复制

---

## 课后思考

1. 为什么MySQL默认隔离级别是REPEATABLE READ，而Oracle是READ COMMITTED？
   - 提示：考虑binlog和主从复制

2. 在REPEATABLE READ级别下，快照读和当前读的区别是什么？
   - 提示：SELECT vs SELECT FOR UPDATE

3. 如果一个事务长时间不提交，会有什么影响？
   - 提示：锁、undo log、MVCC

4. MVCC如何实现一致性读？
   - 提示：Read View、trx_id比较

---

## 下一步

完成本讲后，继续学习：
- **03-索引原理.md**：深入理解B+树索引的原理和优化

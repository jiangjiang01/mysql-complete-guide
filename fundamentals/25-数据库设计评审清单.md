# 25-数据库设计评审清单

> 一份完整的数据库设计评审清单，确保设计质量

---

## 📖 本章目标

- 掌握表设计评审要点
- 掌握索引设计评审要点
- 掌握性能评审要点
- 掌握安全评审要点
- 掌握可维护性评审要点

---

## 一、表设计评审

### 1.1 命名规范

```sql
-- ✅ 检查项：

-- 1. 数据库命名
[ ] 是否使用小写字母+下划线？
[ ] 是否避免了保留字？
[ ] 是否有明确的业务含义？

-- 示例：
✅ ecommerce_db, user_system
❌ EcommerceDB, db1, 电商库

-- 2. 表命名
[ ] 是否使用小写字母+下划线？
[ ] 是否使用复数名词？
[ ] 是否避免了无意义前缀（tbl_、t_）？
[ ] 关联表是否使用两个表名？

-- 示例：
✅ users, order_items, user_roles
❌ tbl_user, User, user-info

-- 3. 字段命名
[ ] 是否使用小写字母+下划线？
[ ] 主键是否命名为id？
[ ] 外键是否命名为{表名}_id？
[ ] 布尔字段是否使用is_开头？
[ ] 时间字段是否使用{动词}_at？

-- 示例：
✅ id, user_id, is_active, created_at
❌ userId, create_time, active
```

### 1.2 字段设计

```sql
-- ✅ 检查项：

-- 1. 数据类型
[ ] 是否选择了最合适的数据类型？
[ ] 整数是否使用INT/BIGINT而非VARCHAR？
[ ] 价格是否使用BIGINT存储分而非DECIMAL存储元？
[ ] 布尔值是否使用TINYINT(1)？
[ ] 是否避免了TEXT/BLOB类型（除非必需）？

-- 示例：
✅ id BIGINT UNSIGNED
✅ price_cents BIGINT UNSIGNED  -- 存储分
✅ is_active TINYINT UNSIGNED
❌ id VARCHAR(20)
❌ price DECIMAL(10, 2)  -- 浮点精度问题

-- 2. 字段长度
[ ] VARCHAR长度是否合理？
[ ] 是否避免了过大的长度（如VARCHAR(1000)）？
[ ] 是否避免了过小的长度？

-- 示例：
✅ username VARCHAR(50)
✅ email VARCHAR(100)
✅ phone VARCHAR(20)
❌ username VARCHAR(500)
❌ email VARCHAR(10)

-- 3. NOT NULL约束
[ ] 是否为所有字段指定了NOT NULL或DEFAULT？
[ ] 是否避免了不必要的NULL？
[ ] 外键字段是否NOT NULL？

-- 示例：
✅ username VARCHAR(50) NOT NULL
✅ email VARCHAR(100) NOT NULL DEFAULT ''
✅ user_id BIGINT UNSIGNED NOT NULL
❌ username VARCHAR(50)  -- 缺少NOT NULL

-- 4. 默认值
[ ] 是否为字段设置了合理的默认值？
[ ] 时间字段是否使用CURRENT_TIMESTAMP？
[ ] 数值字段是否使用0而非NULL？
[ ] 字符串字段是否使用''而非NULL？

-- 示例：
✅ status TINYINT UNSIGNED NOT NULL DEFAULT 1
✅ created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
✅ view_count INT UNSIGNED NOT NULL DEFAULT 0
❌ status TINYINT UNSIGNED  -- 缺少默认值

-- 5. 注释
[ ] 表是否有注释？
[ ] 所有字段是否有注释？
[ ] 枚举值是否在注释中说明？

-- 示例：
✅ status TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '状态：1-正常，2-禁用'
❌ status TINYINT UNSIGNED NOT NULL DEFAULT 1  -- 缺少注释
```

### 1.3 主键设计

```sql
-- ✅ 检查项：

-- 1. 主键类型
[ ] 是否使用BIGINT UNSIGNED AUTO_INCREMENT？
[ ] 是否避免了VARCHAR主键？
[ ] 是否避免了UUID主键（除非分布式）？
[ ] 是否避免了联合主键（除非关联表）？

-- 示例：
✅ id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY
❌ id VARCHAR(36) PRIMARY KEY  -- UUID
❌ PRIMARY KEY (user_id, product_id)  -- 联合主键（业务表）

-- 2. 自增起始值
[ ] 是否设置了AUTO_INCREMENT起始值（可选）？

-- 示例：
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY
) ENGINE=InnoDB AUTO_INCREMENT=1000;  -- 从1000开始
```

### 1.4 通用字段

```sql
-- ✅ 检查项：

-- 1. 必备字段
[ ] 是否包含主键id？
[ ] 是否包含created_at？
[ ] 是否包含updated_at？
[ ] 是否包含deleted_at（软删除）？

-- 示例：
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    -- ... 业务字段 ...
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at DATETIME DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 2. 冗余字段
[ ] 冗余字段是否有必要？
[ ] 是否有更新机制保证一致性？

-- 示例：
✅ orders表冗余username（查询频繁，更新少）
❌ orders表冗余user_email（更新频繁，容易不一致）
```

---

## 二、索引设计评审

### 2.1 索引命名

```sql
-- ✅ 检查项：

-- 1. 索引命名规范
[ ] 主键是否自动命名？
[ ] 唯一索引是否使用uniq_前缀？
[ ] 普通索引是否使用idx_前缀？
[ ] 全文索引是否使用ft_前缀？

-- 示例：
✅ PRIMARY KEY (id)
✅ UNIQUE KEY uniq_username (username)
✅ INDEX idx_status (status)
✅ FULLTEXT INDEX ft_content (content)
❌ INDEX username_index (username)
```

### 2.2 索引设计

```sql
-- ✅ 检查项：

-- 1. 必要索引
[ ] 主键是否有索引（自动创建）？
[ ] 外键字段是否有索引？
[ ] WHERE条件字段是否有索引？
[ ] ORDER BY字段是否有索引？
[ ] GROUP BY字段是否有索引？
[ ] JOIN关联字段是否有索引？

-- 2. 唯一索引
[ ] 业务唯一字段是否创建唯一索引？

-- 示例：
✅ UNIQUE KEY uniq_username (username)
✅ UNIQUE KEY uniq_email (email)
✅ UNIQUE KEY uniq_order_no (order_no)

-- 3. 联合索引
[ ] 是否遵循最左前缀原则？
[ ] 字段顺序是否合理（选择性高的在前）？
[ ] 是否避免了冗余索引？

-- 示例：
-- 已有索引：idx_status_created(status, created_at)
✅ 可以满足查询：WHERE status = 1
✅ 可以满足查询：WHERE status = 1 ORDER BY created_at
❌ 不应再创建：idx_status(status)  -- 冗余

-- 4. 覆盖索引
[ ] 是否考虑了覆盖索引优化？

-- 示例：
-- 查询：SELECT id, username FROM users WHERE status = 1
✅ CREATE INDEX idx_status_username (status, username)  -- 覆盖索引

-- 5. 前缀索引
[ ] 长字符串字段是否使用前缀索引？

-- 示例：
✅ CREATE INDEX idx_email ON users(email(20))  -- 前缀索引
❌ CREATE INDEX idx_email ON users(email)  -- 全字段索引（email很长）

-- 6. 索引数量
[ ] 单表索引数量是否合理（建议≤5个）？
[ ] 是否避免了过多索引影响写入性能？
```

### 2.3 全文索引

```sql
-- ✅ 检查项：

-- 1. 全文索引使用
[ ] 是否为搜索字段创建全文索引？
[ ] 是否使用ngram解析器（支持中文）？

-- 示例：
✅ FULLTEXT INDEX ft_title_content (title, content) WITH PARSER ngram
```

---

## 三、约束设计评审

### 3.1 外键约束

```sql
-- ✅ 检查项：

-- 1. 外键使用
[ ] 是否需要外键约束？
[ ] 是否考虑了性能影响？
[ ] 是否设置了ON DELETE/ON UPDATE策略？

-- 示例：
-- 方案1：使用外键（小系统、强一致性）
CONSTRAINT fk_orders_users
    FOREIGN KEY (user_id) REFERENCES users(id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE

-- 方案2：不使用外键（大系统、性能优先）
-- 应用层保证一致性
```

### 3.2 检查约束

```sql
-- ✅ 检查项：

-- 1. 检查约束使用
[ ] 是否使用CHECK约束验证数据？

-- 示例：
✅ CONSTRAINT ck_users_age CHECK (age >= 0 AND age <= 150)
✅ CONSTRAINT ck_orders_amount CHECK (total_amount >= 0)
```

---

## 四、表结构设计评审

### 4.1 表引擎

```sql
-- ✅ 检查项：

-- 1. 存储引擎
[ ] 是否使用InnoDB？
[ ] 是否避免了MyISAM（除非特殊场景）？

-- 示例：
✅ ENGINE=InnoDB
❌ ENGINE=MyISAM
```

### 4.2 字符集

```sql
-- ✅ 检查项：

-- 1. 字符集
[ ] 是否使用utf8mb4？
[ ] 是否避免了utf8（不支持emoji）？
[ ] 是否使用utf8mb4_unicode_ci排序规则？

-- 示例：
✅ DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
❌ DEFAULT CHARSET=utf8
❌ DEFAULT CHARSET=latin1
```

### 4.3 表分区

```sql
-- ✅ 检查项：

-- 1. 分区使用
[ ] 大表是否考虑分区？
[ ] 分区键是否合理？
[ ] 是否便于数据归档？

-- 示例：
-- 日志表按月分区
CREATE TABLE logs (
    id BIGINT UNSIGNED AUTO_INCREMENT,
    created_at DATETIME NOT NULL,
    ...
    PRIMARY KEY (id, created_at)
)
PARTITION BY RANGE (YEAR(created_at) * 100 + MONTH(created_at)) (
    PARTITION p202401 VALUES LESS THAN (202402),
    PARTITION p202402 VALUES LESS THAN (202403),
    ...
);
```

---

## 五、性能评审

### 5.1 查询性能

```sql
-- ✅ 检查项：

-- 1. 索引覆盖
[ ] 常用查询是否使用了索引？
[ ] 是否避免了全表扫描？
[ ] 是否使用了EXPLAIN分析？

-- 示例：
EXPLAIN SELECT * FROM users WHERE status = 1;
-- 检查type字段（期望：ref, range, index）

-- 2. 避免慢查询
[ ] 是否避免了SELECT *？
[ ] 是否避免了OR条件？
[ ] 是否避免了NOT IN？
[ ] 是否避免了前导模糊查询（LIKE '%xxx'）？
[ ] 是否避免了函数操作索引列？

-- 3. JOIN优化
[ ] JOIN表数量是否合理（≤3张表）？
[ ] JOIN字段是否有索引？
[ ] 是否遵循小表驱动大表？
```

### 5.2 写入性能

```sql
-- ✅ 检查项：

-- 1. 批量操作
[ ] INSERT是否使用批量插入？
[ ] UPDATE是否使用批量更新？
[ ] DELETE是否使用批量删除？

-- 2. 索引数量
[ ] 索引数量是否合理（避免过多）？
[ ] 是否影响写入性能？
```

---

## 六、安全评审

### 6.1 数据安全

```sql
-- ✅ 检查项：

-- 1. 密码存储
[ ] 密码是否加密存储（bcrypt、argon2）？
[ ] 是否避免了明文存储？

-- 2. 敏感数据
[ ] 敏感数据是否加密？
[ ] 查询时是否脱敏？

-- 示例：
-- 身份证号脱敏
SELECT CONCAT(LEFT(id_card, 6), '********', RIGHT(id_card, 4)) AS id_card
FROM users;

-- 3. SQL注入
[ ] 是否使用参数化查询？
[ ] 是否避免了字符串拼接？
```

### 6.2 权限控制

```sql
-- ✅ 检查项：

-- 1. 用户权限
[ ] 应用程序是否使用专用用户？
[ ] 是否遵循最小权限原则？
[ ] 是否避免了使用root用户？

-- 2. 数据访问
[ ] 是否有软删除机制？
[ ] 是否有操作日志？
```

---

## 七、可维护性评审

### 7.1 代码规范

```sql
-- ✅ 检查项：

-- 1. 命名规范
[ ] 是否遵循命名规范？
[ ] 是否有注释？

-- 2. SQL规范
[ ] 关键字是否大写？
[ ] 是否有适当的缩进？
[ ] 是否易于阅读？
```

### 7.2 扩展性

```sql
-- ✅ 检查项：

-- 1. 数据增长
[ ] 是否考虑了数据增长？
[ ] 单表数据量是否可控（<1000万）？
[ ] 是否有分库分表计划？

-- 2. 字段扩展
[ ] 是否预留了扩展字段？
[ ] 是否考虑了JSON字段？

-- 示例：
-- 方案1：预留扩展字段
extra_field_1 VARCHAR(100) DEFAULT NULL,
extra_field_2 VARCHAR(100) DEFAULT NULL

-- 方案2：使用JSON
extra_data JSON DEFAULT NULL
```

---

## 八、完整评审清单

### 8.1 表设计清单

```text
表设计评审清单
=================

1. 命名规范
   [ ] 数据库命名规范
   [ ] 表命名规范
   [ ] 字段命名规范
   [ ] 避免保留字

2. 字段设计
   [ ] 数据类型合理
   [ ] 字段长度合理
   [ ] NOT NULL约束
   [ ] 默认值设置
   [ ] 字段注释

3. 主键设计
   [ ] 使用BIGINT UNSIGNED AUTO_INCREMENT
   [ ] 避免VARCHAR主键
   [ ] 避免联合主键（业务表）

4. 通用字段
   [ ] id主键
   [ ] created_at
   [ ] updated_at
   [ ] deleted_at（软删除）

5. 表属性
   [ ] ENGINE=InnoDB
   [ ] DEFAULT CHARSET=utf8mb4
   [ ] COLLATE=utf8mb4_unicode_ci
   [ ] 表注释
```

### 8.2 索引设计清单

```text
索引设计评审清单
=================

1. 索引命名
   [ ] PRIMARY KEY (id)
   [ ] UNIQUE KEY uniq_xxx
   [ ] INDEX idx_xxx
   [ ] FULLTEXT INDEX ft_xxx

2. 必要索引
   [ ] 外键字段索引
   [ ] WHERE条件字段索引
   [ ] ORDER BY字段索引
   [ ] JOIN字段索引

3. 联合索引
   [ ] 遵循最左前缀
   [ ] 字段顺序合理
   [ ] 避免冗余索引

4. 索引优化
   [ ] 考虑覆盖索引
   [ ] 长字段使用前缀索引
   [ ] 索引数量合理（≤5）
```

### 8.3 性能评审清单

```text
性能评审清单
=============

1. 查询性能
   [ ] 使用EXPLAIN分析
   [ ] 避免SELECT *
   [ ] 避免全表扫描
   [ ] 避免OR条件
   [ ] 避免NOT IN
   [ ] 避免前导模糊查询
   [ ] 避免函数操作索引列

2. 写入性能
   [ ] 使用批量操作
   [ ] 索引数量合理
   [ ] 避免长事务

3. JOIN优化
   [ ] JOIN表数量≤3
   [ ] JOIN字段有索引
   [ ] 小表驱动大表
```

### 8.4 安全评审清单

```text
安全评审清单
=============

1. 数据安全
   [ ] 密码加密存储
   [ ] 敏感数据加密
   [ ] 查询时脱敏

2. SQL安全
   [ ] 使用参数化查询
   [ ] 避免字符串拼接
   [ ] 防止SQL注入

3. 权限控制
   [ ] 使用专用用户
   [ ] 最小权限原则
   [ ] 避免使用root

4. 数据保护
   [ ] 软删除机制
   [ ] 操作日志
   [ ] 定期备份
```

---

## 九、评审流程

### 9.1 设计阶段

```text
1. 需求分析
   - 明确业务需求
   - 确定数据量级
   - 确定性能要求

2. 概要设计
   - ER图设计
   - 表结构设计
   - 索引设计

3. 详细设计
   - 字段定义
   - 约束定义
   - 注释编写
```

### 9.2 评审阶段

```text
1. 自查
   - 使用本清单自查
   - 使用EXPLAIN分析
   - 性能测试

2. 代码评审
   - 命名规范
   - 索引设计
   - 性能优化

3. DBA评审
   - 表结构设计
   - 索引设计
   - 性能评估
```

### 9.3 上线阶段

```text
1. 测试验证
   - 功能测试
   - 性能测试
   - 压力测试

2. 灰度发布
   - 小流量验证
   - 监控数据

3. 全量上线
   - 持续监控
   - 及时优化
```

---

## 十、评审工具

### 10.1 自动化检查工具

```python
-- 1. Sonar-MySQL
-- 静态代码分析工具，检查SQL规范

-- 2. pt-query-digest
-- 分析慢查询日志
pt-query-digest slow.log

-- 3. MySQLTuner
-- 性能优化建议
perl mysqltuner.pl

-- 4. Percona Toolkit
-- 数据库管理工具集
pt-online-schema-change  # 在线DDL
pt-table-checksum        # 数据一致性检查
pt-duplicate-key-checker # 重复索引检查
```

### 10.2 手动检查命令

```sql
-- 1. 查看表结构
SHOW CREATE TABLE users;

-- 2. 查看索引
SHOW INDEX FROM users;

-- 3. 分析表
ANALYZE TABLE users;

-- 4. 检查表
CHECK TABLE users;

-- 5. 优化表
OPTIMIZE TABLE users;

-- 6. 查看表状态
SHOW TABLE STATUS LIKE 'users';

-- 7. 查看字符集
SHOW VARIABLES LIKE 'character%';

-- 8. 查看存储引擎
SHOW ENGINES;
```

---

## 十一、本章总结

### 核心要点

1. **表设计**：
   - 命名规范
   - 字段设计
   - 主键设计
   - 通用字段

2. **索引设计**：
   - 索引命名
   - 必要索引
   - 联合索引
   - 索引优化

3. **性能优化**：
   - 查询优化
   - 写入优化
   - JOIN优化

4. **安全设计**：
   - 数据安全
   - SQL安全
   - 权限控制

5. **可维护性**：
   - 代码规范
   - 扩展性
   - 注释完整

### 下一步

完成本章学习后，你应该能够：
- ✅ 进行完整的数据库设计评审
- ✅ 识别设计问题
- ✅ 提出优化建议
- ✅ 保证设计质量
- ✅ 确保可维护性

---

## 🎉 恭喜！

你已经完成了《MySQL CRUD实战教程》的全部学习！

### 学习回顾

你已经掌握了：

**第一章：数据库设计基础**
- 表设计基础与规范
- 主键与索引设计
- 表关系设计
- 范式与反范式
- 常用表设计模式

**第二章：单表操作**
- 单表增删改查基础
- WHERE条件查询
- 聚合与分组查询
- 排序与分页

**第三章：多表查询**
- 表关联查询基础
- 子查询
- 复杂查询场景
- 常见业务查询模式

**第四章：业务场景实战**
- 用户系统设计与实现
- 订单系统设计与实现
- 内容管理系统设计与实现
- 营销系统设计与实现
- 数据分析查询

**第五章：性能优化**
- 索引优化实战
- 查询优化实战
- 写入优化实战
- 缓存与架构优化

**第六章：最佳实践**
- SQL编写规范
- 常见陷阱与解决方案
- 数据库设计评审清单

### 继续学习

1. **深入学习**：
   - MySQL官方文档
   - 《高性能MySQL》
   - 《MySQL实战45讲》

2. **实战练习**：
   - 参与开源项目
   - 设计实际业务系统
   - 性能优化实战

3. **持续关注**：
   - MySQL新版本特性
   - 数据库技术发展
   - 最佳实践更新

祝你在MySQL学习之路上越走越远！🚀

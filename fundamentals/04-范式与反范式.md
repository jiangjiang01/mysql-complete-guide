# 04-范式与反范式

> 理解数据库范式理论，掌握何时遵循范式、何时打破范式

---

## 📖 本章目标

- 理解三范式的定义和作用
- 掌握范式化设计的方法
- 理解反范式设计的场景
- 学会在性能和一致性之间取得平衡

---

## 一、范式理论概述

### 1.1 什么是范式

**范式（Normal Form）**：数据库设计的规范，用于减少数据冗余、避免数据异常

**范式级别**：
```
1NF（第一范式）→ 2NF（第二范式）→ 3NF（第三范式）→ BCNF → 4NF → 5NF
                常用范围
```

**实际应用**：
- 一般达到 **3NF** 即可
- BCNF、4NF、5NF 过于严格，实际很少使用

---

## 二、第一范式（1NF）

### 2.1 定义

**字段不可再分（原子性）**

### 2.2 违反1NF的示例

```sql
-- ❌ 违反1NF：地址字段可再分
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    address VARCHAR(255) NOT NULL  -- "北京市海淀区中关村大街1号"
) ENGINE=InnoDB;

-- 问题：
-- 1. 无法按省、市、区查询
-- 2. 无法统计各地区用户数量
```

### 2.3 符合1NF的设计

```sql
-- ✅ 符合1NF：字段原子化
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,

    -- 地址字段拆分
    province VARCHAR(50) NOT NULL DEFAULT '' COMMENT '省',
    city VARCHAR(50) NOT NULL DEFAULT '' COMMENT '市',
    district VARCHAR(50) NOT NULL DEFAULT '' COMMENT '区',
    street VARCHAR(255) NOT NULL DEFAULT '' COMMENT '街道',

    INDEX idx_province (province),
    INDEX idx_city (city)
) ENGINE=InnoDB;

-- 现在可以：
-- 1. 查询某省的用户
SELECT * FROM users WHERE province = '北京市';

-- 2. 统计各省用户数量
SELECT province, COUNT(*) AS user_count
FROM users
GROUP BY province;
```

### 2.4 1NF的灵活性

**何时可以不完全原子化**：

```sql
-- 示例：JSON字段存储地址
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,

    -- 地址信息（JSON格式）
    address JSON COMMENT '地址信息'
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO users (username, address) VALUES
('zhangsan', '{"province": "北京市", "city": "北京市", "district": "海淀区", "street": "中关村大街1号"}');

-- 查询某省用户（MySQL 5.7.8+）
SELECT * FROM users
WHERE JSON_EXTRACT(address, '$.province') = '北京市';

-- 适用场景：
-- 1. 扩展字段（属性不固定）
-- 2. 查询频率低的字段
-- 3. 地址等层级结构数据
```

---

## 三、第二范式（2NF）

### 3.1 定义

**满足1NF，且非主键字段完全依赖于主键（消除部分依赖）**

**前提**：只针对**复合主键**的表

### 3.2 违反2NF的示例

```sql
-- ❌ 违反2NF：存在部分依赖
CREATE TABLE order_items (
    -- 复合主键
    order_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,

    -- 订单信息（只依赖order_id，部分依赖）
    order_date DATETIME NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,

    -- 商品信息（只依赖product_id，部分依赖）
    product_name VARCHAR(200) NOT NULL,
    product_price BIGINT UNSIGNED NOT NULL,

    -- 订单明细信息（完全依赖order_id和product_id）
    quantity INT UNSIGNED NOT NULL,
    subtotal BIGINT UNSIGNED NOT NULL,

    PRIMARY KEY (order_id, product_id)
) ENGINE=InnoDB;

-- 问题：
-- 1. 数据冗余：每个订单明细都重复存储订单信息
-- 2. 更新异常：更新订单日期需要更新所有明细
-- 3. 插入异常：订单没有商品时无法插入订单信息
-- 4. 删除异常：删除所有明细会丢失订单信息
```

### 3.3 符合2NF的设计

```sql
-- ✅ 符合2NF：拆分成多张表

-- 订单表（订单信息）
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,
    order_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    total_amount BIGINT UNSIGNED NOT NULL,

    UNIQUE KEY uniq_order_no (order_no),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 商品表（商品信息）
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL,
    stock INT UNSIGNED NOT NULL DEFAULT 0,

    INDEX idx_price_cents (price_cents)
) ENGINE=InnoDB;

-- 订单明细表（只存关联信息和明细数据）
CREATE TABLE order_items (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,

    -- 明细信息
    quantity INT UNSIGNED NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL COMMENT '下单时的价格（快照）',
    subtotal BIGINT UNSIGNED NOT NULL,

    INDEX idx_order_id (order_id),
    INDEX idx_product_id (product_id)
) ENGINE=InnoDB;

-- 查询订单详情
SELECT
    o.order_no,
    o.order_date,
    o.total_amount,
    p.name AS product_name,
    oi.quantity,
    oi.price_cents,
    oi.subtotal
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE o.id = 1;
```

---

## 四、第三范式（3NF）

### 4.1 定义

**满足2NF，且非主键字段不传递依赖于主键（消除传递依赖）**

**传递依赖**：A → B → C（C传递依赖于A）

### 4.2 违反3NF的示例

```sql
-- ❌ 违反3NF：存在传递依赖
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,

    -- 用户ID（直接依赖主键）
    user_id BIGINT UNSIGNED NOT NULL,

    -- 用户信息（传递依赖：id → user_id → username/email）
    username VARCHAR(50) NOT NULL,
    user_email VARCHAR(100) NOT NULL,

    total_amount BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_order_no (order_no)
) ENGINE=InnoDB;

-- 问题：
-- 1. 数据冗余：用户信息在每个订单中重复存储
-- 2. 更新异常：用户修改邮箱，需要更新所有订单
-- 3. 插入异常：用户没下单时无法记录用户信息
```

### 4.3 符合3NF的设计

```sql
-- ✅ 符合3NF：拆分用户表和订单表

-- 用户表
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email)
) ENGINE=InnoDB;

-- 订单表（只存用户ID，不存用户信息）
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,

    -- 外键字段
    user_id BIGINT UNSIGNED NOT NULL,

    total_amount BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_order_no (order_no),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 查询订单及用户信息
SELECT
    o.order_no,
    o.total_amount,
    u.username,
    u.email
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.id = 1;
```

### 4.4 另一个3NF示例

```sql
-- ❌ 违反3NF：部门信息传递依赖
CREATE TABLE employees (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,

    -- 部门ID（直接依赖）
    department_id BIGINT UNSIGNED NOT NULL,

    -- 部门信息（传递依赖：id → department_id → department_name/location）
    department_name VARCHAR(100) NOT NULL,
    department_location VARCHAR(100) NOT NULL,

    salary BIGINT UNSIGNED NOT NULL
) ENGINE=InnoDB;

-- ✅ 符合3NF：拆分员工表和部门表
CREATE TABLE departments (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    location VARCHAR(100) NOT NULL
) ENGINE=InnoDB;

CREATE TABLE employees (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    department_id BIGINT UNSIGNED NOT NULL,
    salary BIGINT UNSIGNED NOT NULL,

    INDEX idx_department_id (department_id)
) ENGINE=InnoDB;
```

---

## 五、范式化的优缺点

### 5.1 范式化的优点

```sql
-- ✅ 优点示例：数据一致性

-- 用户表
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    UNIQUE KEY uniq_email (email)
) ENGINE=InnoDB;

-- 订单表（不存储用户邮箱）
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,

    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 用户修改邮箱：只需更新一个地方
UPDATE users SET email = 'newemail@example.com' WHERE id = 1;

-- 查询订单时总能获取最新邮箱
SELECT o.*, u.email
FROM orders o
JOIN users u ON o.user_id = u.id;
```

**优点总结**：
1. ✅ **减少数据冗余**：每个数据只存储一次
2. ✅ **数据一致性高**：修改一处即可，不会出现不一致
3. ✅ **节省存储空间**
4. ✅ **插入、更新、删除操作简单**

### 5.2 范式化的缺点

```sql
-- ❌ 缺点示例：查询需要多次JOIN

-- 查询订单详情（需要3次JOIN）
SELECT
    o.order_no,
    u.username,
    u.email,
    p.name AS product_name,
    oi.quantity,
    oi.price_cents
FROM orders o
JOIN users u ON o.user_id = u.id           -- JOIN 1
JOIN order_items oi ON o.id = oi.order_id  -- JOIN 2
JOIN products p ON oi.product_id = p.id    -- JOIN 3
WHERE o.id = 1;

-- 性能问题：
-- 1. 多次JOIN，查询慢
-- 2. 需要访问多张表
-- 3. 索引使用复杂
```

**缺点总结**：
1. ❌ **查询复杂**：需要多表JOIN
2. ❌ **查询性能差**：JOIN操作耗时
3. ❌ **应用程序复杂**：需要处理复杂的关联查询

---

## 六、反范式设计

### 6.1 什么是反范式

**反范式（Denormalization）**：有意引入冗余，提高查询性能

**适用场景**：
1. **查询频率远高于更新频率**
2. **JOIN操作影响性能**
3. **统计字段**
4. **历史数据快照**

### 6.2 反范式场景一：冗余用户名

```sql
-- 场景：评论列表需要显示用户名，但不需要JOIN用户表

-- ✅ 反范式设计：冗余username
CREATE TABLE comments (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    article_id BIGINT UNSIGNED NOT NULL,

    -- 关联字段
    user_id BIGINT UNSIGNED NOT NULL,

    -- 冗余字段：用户名
    username VARCHAR(50) NOT NULL COMMENT '冗余字段，便于查询',

    content TEXT NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_article_id (article_id),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 查询评论列表（无需JOIN）
SELECT
    id,
    username,  -- 直接获取，无需JOIN
    content,
    created_at
FROM comments
WHERE article_id = 1
ORDER BY created_at DESC;

-- 维护冗余数据
-- 用户修改用户名时，需要同步更新comments表
UPDATE comments SET username = 'newname' WHERE user_id = 1;
```

**权衡**：
- ✅ 查询性能：无需JOIN，查询快
- ❌ 数据一致性：需要维护冗余数据
- ❌ 存储空间：冗余字段占用空间

### 6.3 反范式场景二：统计字段

```sql
-- 场景：文章表需要显示评论数、点赞数

-- 范式化设计（❌ 性能差）
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL
) ENGINE=InnoDB;

CREATE TABLE comments (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    article_id BIGINT UNSIGNED NOT NULL,
    content TEXT NOT NULL,

    INDEX idx_article_id (article_id)
) ENGINE=InnoDB;

-- 查询文章及评论数（需要JOIN + COUNT）
SELECT
    a.id,
    a.title,
    COUNT(c.id) AS comment_count  -- 每次查询都要COUNT
FROM articles a
LEFT JOIN comments c ON a.id = c.article_id
GROUP BY a.id, a.title;

-- 反范式设计（✅ 性能好）
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,

    -- 冗余统计字段
    comment_count INT UNSIGNED NOT NULL DEFAULT 0,
    like_count INT UNSIGNED NOT NULL DEFAULT 0,
    view_count INT UNSIGNED NOT NULL DEFAULT 0,

    INDEX idx_comment_count (comment_count),
    INDEX idx_like_count (like_count)
) ENGINE=InnoDB;

-- 查询文章及评论数（无需JOIN）
SELECT
    id,
    title,
    comment_count,  -- 直接获取
    like_count,
    view_count
FROM articles
ORDER BY comment_count DESC
LIMIT 10;

-- 维护统计字段
-- 新增评论时，更新文章的comment_count
INSERT INTO comments (article_id, content) VALUES (1, '评论内容');
UPDATE articles SET comment_count = comment_count + 1 WHERE id = 1;

-- 删除评论时，更新文章的comment_count
DELETE FROM comments WHERE id = 100;
UPDATE articles SET comment_count = comment_count - 1 WHERE article_id = 1;
```

### 6.4 反范式场景三：历史数据快照

```sql
-- 场景：订单明细需要保存下单时的商品价格

-- 商品表（价格会变动）
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL  -- 当前价格，会变动
) ENGINE=InnoDB;

-- 订单明细表
CREATE TABLE order_items (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,

    -- 冗余字段：下单时的商品信息（快照）
    product_name VARCHAR(200) NOT NULL COMMENT '商品名称快照',
    price_cents BIGINT UNSIGNED NOT NULL COMMENT '下单时的价格快照',

    quantity INT UNSIGNED NOT NULL,
    subtotal BIGINT UNSIGNED NOT NULL,

    INDEX idx_order_id (order_id)
) ENGINE=InnoDB;

-- 下单时，保存当前商品信息
INSERT INTO order_items (order_id, product_id, product_name, price_cents, quantity, subtotal)
SELECT
    1 AS order_id,
    p.id AS product_id,
    p.name AS product_name,
    p.price_cents AS price_cents,
    2 AS quantity,
    p.price_cents * 2 AS subtotal
FROM products p
WHERE p.id = 100;

-- 即使商品价格变动，订单明细仍保留下单时的价格
UPDATE products SET price_cents = 20000 WHERE id = 100;

-- 查询订单明细（显示下单时的价格）
SELECT
    product_name,
    price_cents,  -- 下单时的价格，不受商品价格变动影响
    quantity,
    subtotal
FROM order_items
WHERE order_id = 1;
```

### 6.5 反范式场景四：JSON字段

```sql
-- 场景：订单详情需要保存收货地址，但地址可能变动

CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,

    -- 冗余字段：收货地址快照（JSON）
    shipping_address JSON COMMENT '收货地址快照',

    total_amount BIGINT UNSIGNED NOT NULL,

    UNIQUE KEY uniq_order_no (order_no),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 下单时，保存当前收货地址
INSERT INTO orders (order_no, user_id, shipping_address, total_amount)
SELECT
    'ORDER001',
    1,
    JSON_OBJECT(
        'name', '张三',
        'phone', '13800138000',
        'province', '北京市',
        'city', '北京市',
        'district', '海淀区',
        'street', '中关村大街1号'
    ),
    10000;

-- 查询订单（即使用户修改了地址，订单仍保留下单时的地址）
SELECT
    order_no,
    JSON_EXTRACT(shipping_address, '$.name') AS recipient_name,
    JSON_EXTRACT(shipping_address, '$.phone') AS recipient_phone,
    shipping_address->>'$.province' AS province,
    shipping_address->>'$.city' AS city
FROM orders
WHERE id = 1;
```

---

## 七、范式 vs 反范式的选择

### 7.1 决策矩阵

| 因素 | 范式化 | 反范式 |
|------|--------|--------|
| 数据一致性要求 | 高 | 中 |
| 查询频率 | 低-中 | 高 |
| 更新频率 | 高 | 低 |
| JOIN性能影响 | 小 | 大 |
| 存储空间 | 紧张 | 充足 |
| 应用复杂度 | 简单 | 复杂 |

### 7.2 实战建议

**推荐做法**：

1. **核心业务表：范式化**
   ```sql
   -- 用户表、商品表、订单表等核心表，保持范式化
   CREATE TABLE users (...);
   CREATE TABLE products (...);
   CREATE TABLE orders (...);
   ```

2. **关联表：冗余常用字段**
   ```sql
   -- 评论表：冗余username
   CREATE TABLE comments (
       user_id BIGINT UNSIGNED NOT NULL,
       username VARCHAR(50) NOT NULL  -- 冗余
   );
   ```

3. **统计字段：冗余**
   ```sql
   -- 文章表：冗余统计字段
   CREATE TABLE articles (
       comment_count INT UNSIGNED DEFAULT 0,  -- 冗余
       like_count INT UNSIGNED DEFAULT 0      -- 冗余
   );
   ```

4. **历史快照：冗余**
   ```sql
   -- 订单明细：保存下单时的商品信息
   CREATE TABLE order_items (
       product_name VARCHAR(200),   -- 冗余
       price_cents BIGINT UNSIGNED  -- 冗余
   );
   ```

### 7.3 平衡示例：电商订单系统

```sql
-- 用户表（范式化）
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 商品表（范式化）
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL,
    stock INT UNSIGNED NOT NULL DEFAULT 0
) ENGINE=InnoDB;

-- 订单表（部分反范式）
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,

    -- 关联字段
    user_id BIGINT UNSIGNED NOT NULL,

    -- 冗余字段：用户名（查询订单列表时常用）
    username VARCHAR(50) NOT NULL,

    -- 冗余字段：收货地址快照（JSON）
    shipping_address JSON,

    total_amount BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,

    UNIQUE KEY uniq_order_no (order_no),
    INDEX idx_user_id (user_id),
    INDEX idx_username (username)
) ENGINE=InnoDB;

-- 订单明细表（反范式：保存商品快照）
CREATE TABLE order_items (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,

    -- 关联字段
    product_id BIGINT UNSIGNED NOT NULL,

    -- 冗余字段：商品快照
    product_name VARCHAR(200) NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL,

    quantity INT UNSIGNED NOT NULL,
    subtotal BIGINT UNSIGNED NOT NULL,

    INDEX idx_order_id (order_id)
) ENGINE=InnoDB;

-- 查询订单列表（无需JOIN users表）
SELECT
    order_no,
    username,  -- 直接获取，无需JOIN
    total_amount,
    status,
    created_at
FROM orders
WHERE user_id = 1
ORDER BY created_at DESC;

-- 查询订单详情（无需JOIN products表）
SELECT
    oi.product_name,  -- 下单时的商品名
    oi.price_cents,   -- 下单时的价格
    oi.quantity,
    oi.subtotal
FROM order_items oi
WHERE oi.order_id = 1;
```

---

## 八、实战案例

### 案例：内容管理系统的设计

```sql
-- 用户表（范式化）
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    avatar VARCHAR(255) NOT NULL DEFAULT '',

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 文章表（部分反范式）
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,

    -- 关联字段
    author_id BIGINT UNSIGNED NOT NULL,

    -- 冗余字段：作者信息（查询文章列表时常用）
    author_username VARCHAR(50) NOT NULL,
    author_avatar VARCHAR(255) NOT NULL DEFAULT '',

    -- 冗余字段：统计信息
    view_count INT UNSIGNED NOT NULL DEFAULT 0,
    like_count INT UNSIGNED NOT NULL DEFAULT 0,
    comment_count INT UNSIGNED NOT NULL DEFAULT 0,

    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_author_id (author_id),
    INDEX idx_view_count (view_count),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB;

-- 评论表（部分反范式）
CREATE TABLE comments (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

    -- 关联字段
    article_id BIGINT UNSIGNED NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,

    -- 冗余字段：用户信息
    username VARCHAR(50) NOT NULL,
    user_avatar VARCHAR(255) NOT NULL DEFAULT '',

    content TEXT NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_article_id (article_id),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 查询文章列表（无需JOIN users表）
SELECT
    id,
    title,
    author_username,  -- 直接获取
    author_avatar,    -- 直接获取
    view_count,
    like_count,
    comment_count,
    created_at
FROM articles
WHERE status = 2
ORDER BY created_at DESC
LIMIT 20;

-- 查询文章评论（无需JOIN users表）
SELECT
    username,      -- 直接获取
    user_avatar,   -- 直接获取
    content,
    created_at
FROM comments
WHERE article_id = 1
ORDER BY created_at DESC;

-- 维护冗余数据（用户修改头像时）
BEGIN;
UPDATE users SET avatar = 'new_avatar.jpg' WHERE id = 1;
UPDATE articles SET author_avatar = 'new_avatar.jpg' WHERE author_id = 1;
UPDATE comments SET user_avatar = 'new_avatar.jpg' WHERE user_id = 1;
COMMIT;
```

---

## 九、本章总结

### 核心要点

1. **三范式**：
   - 1NF：字段原子性
   - 2NF：消除部分依赖（针对复合主键）
   - 3NF：消除传递依赖

2. **范式化**：
   - ✅ 减少冗余、保证一致性
   - ❌ 查询复杂、性能差

3. **反范式**：
   - ✅ 提高查询性能
   - ❌ 数据冗余、维护复杂

4. **选择策略**：
   - 核心表：范式化
   - 常用字段：冗余
   - 统计字段：冗余
   - 历史快照：冗余

5. **平衡原则**：
   - 根据业务场景选择
   - 查询多→反范式
   - 更新多→范式化

### 下一步

完成本章学习后，你应该能够：
- ✅ 理解三范式的定义
- ✅ 识别违反范式的设计
- ✅ 根据场景选择范式或反范式
- ✅ 设计平衡的数据库结构

下一章我们将学习 **常用表设计模式**，掌握软删除、时间戳、状态字段等实用设计模式。

---

**🎉 恭喜完成第四节学习！**

下一节：[05-常用表设计模式](./05-常用表设计模式.md)

# 02-主键与索引设计

> 深入理解主键和索引的设计策略，为高性能数据库打下基础

---

## 📖 本章目标

- 理解主键的作用和设计策略
- 掌握不同主键方案的优缺点
- 学会设计唯一索引和普通索引
- 理解索引设计的基本原则

---

## 一、主键设计

### 1.1 主键的作用

**主键（PRIMARY KEY）**的特性：
1. **唯一性**：表中每行数据的唯一标识
2. **非空性**：主键字段不能为NULL
3. **聚簇索引**：InnoDB中，数据按主键顺序物理存储
4. **唯一约束**：自动创建唯一索引

### 1.2 主键设计策略对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 自增ID | 简单、性能好、占用空间小 | 分布式ID冲突、可被猜测 | 单体应用、中小型系统 |
| UUID | 全局唯一、分布式友好 | 占用空间大（36字节）、无序插入性能差 | 需要全局唯一ID的场景 |
| 雪花ID | 全局唯一、有序、性能好 | 依赖时钟、需要额外逻辑生成 | 分布式系统、大型系统 |
| 复合主键 | 符合业务逻辑 | 占用空间大、JOIN性能差 | 多对多关联表 |

---

### 1.3 方案一：自增ID（AUTO_INCREMENT）

#### 特点

- MySQL原生支持
- 整数类型，占用空间小（BIGINT 8字节）
- 单调递增，插入性能好
- 索引效率高

#### 语法

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL
) ENGINE=InnoDB;

-- 查看当前自增值
SHOW CREATE TABLE users;

-- 设置自增起始值
ALTER TABLE users AUTO_INCREMENT = 10000;
```

#### 实战示例

```sql
-- 创建用户表（自增ID）
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID',
    username VARCHAR(50) NOT NULL COMMENT '用户名',
    email VARCHAR(100) NOT NULL COMMENT '邮箱',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email)
) ENGINE=InnoDB AUTO_INCREMENT=10000 COMMENT='用户表';

-- 插入数据（不指定ID，自动生成）
INSERT INTO users (username, email) VALUES
('zhangsan', 'zhangsan@example.com'),
('lisi', 'lisi@example.com'),
('wangwu', 'wangwu@example.com');

-- 查询数据
SELECT * FROM users;
-- id会自动生成：10000, 10001, 10002

-- 查看最后插入的ID
SELECT LAST_INSERT_ID();
```

#### 自增ID的问题

**问题1：分布式ID冲突**
```sql
-- 多个数据库实例，ID会冲突
-- DB1: INSERT -> id=1
-- DB2: INSERT -> id=1  ❌ 冲突
```

**问题2：ID可被猜测**
```sql
-- 用户可以猜测其他用户的ID
-- https://example.com/users/10001
-- https://example.com/users/10002  ← 可以猜测并访问
```

**问题3：自增ID用尽**
```sql
-- INT UNSIGNED: 最大42亿
-- 建议使用BIGINT UNSIGNED: 最大1844京
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY  -- ✅ 推荐
    -- id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY  -- ❌ 不推荐
);
```

#### 最佳实践

```sql
-- ✅ 推荐：BIGINT UNSIGNED
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    -- ...
) ENGINE=InnoDB AUTO_INCREMENT=10000;

-- 优点：
-- 1. 空间占用合理（8字节）
-- 2. 性能最好
-- 3. 代码简单
-- 4. 索引效率高

-- 适用场景：
-- 1. 单体应用
-- 2. 中小型系统
-- 3. 内部业务系统
```

---

### 1.4 方案二：UUID

#### 特点

- 全局唯一（Universally Unique Identifier）
- 无需中心化生成
- 36字节（含连字符）或16字节（去连字符）
- 无序，插入性能差

#### UUID格式

```
8-4-4-4-12（36字符，含连字符）
550e8400-e29b-41d4-a716-446655440000
```

#### 实战示例

```sql
-- 方式1：CHAR(36) 存储带连字符的UUID
CREATE TABLE users (
    id CHAR(36) PRIMARY KEY COMMENT '用户ID',
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO users (id, username, email) VALUES
(UUID(), 'zhangsan', 'zhangsan@example.com'),
(UUID(), 'lisi', 'lisi@example.com');

SELECT * FROM users;
-- id: 550e8400-e29b-41d4-a716-446655440000

-- 方式2：BINARY(16) 存储去连字符的UUID（节省空间）
CREATE TABLE users_v2 (
    id BINARY(16) PRIMARY KEY,
    username VARCHAR(50) NOT NULL
) ENGINE=InnoDB;

-- 插入数据（需要转换）
INSERT INTO users_v2 (id, username) VALUES
(UNHEX(REPLACE(UUID(), '-', '')), 'zhangsan');

-- 查询数据（转换回可读格式）
SELECT
    HEX(id) AS id,
    INSERT(INSERT(INSERT(INSERT(HEX(id), 9, 0, '-'), 14, 0, '-'), 19, 0, '-'), 24, 0, '-') AS uuid,
    username
FROM users_v2;
```

#### UUID的优缺点

**优点**：
- ✅ 全局唯一，分布式友好
- ✅ 无需中心化生成
- ✅ 不可猜测，安全性高

**缺点**：
- ❌ 占用空间大（CHAR(36) 36字节 vs BIGINT 8字节）
- ❌ 无序，插入性能差（B+树页分裂）
- ❌ 索引空间占用大
- ❌ 可读性差

#### 最佳实践

```sql
-- ✅ 如果必须使用UUID，推荐使用有序UUID（MySQL 8.0+）
-- UUID_TO_BIN()：转换为二进制，节省空间
-- BIN_TO_UUID()：转换回字符串，便于查看

-- MySQL 8.0+
CREATE TABLE users (
    id BINARY(16) PRIMARY KEY DEFAULT (UUID_TO_BIN(UUID(), 1)),
    -- UUID_TO_BIN(UUID(), 1)：第二个参数1表示时间部分在前，有序
    username VARCHAR(50) NOT NULL
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO users (username) VALUES ('zhangsan');

-- 查询数据
SELECT BIN_TO_UUID(id, 1) AS id, username FROM users;

-- 适用场景：
-- 1. 分布式系统，需要在多个节点生成ID
-- 2. 需要离线生成ID（前端、客户端）
-- 3. 对ID安全性要求高的场景
```

---

### 1.5 方案三：雪花ID（Snowflake）

#### 原理

雪花ID是Twitter开源的分布式ID生成算法，64位整数，结构如下：

```
0 - 41位时间戳 - 10位机器ID - 12位序列号
|   （毫秒）     （数据中心+机器）（每毫秒可生成4096个ID）
```

**示例**：
```
1234567890123456789（19位数字）
```

#### 特点

- 64位整数（BIGINT，8字节）
- 全局唯一
- 时间有序（高位是时间戳）
- 高性能（每秒可生成409.6万个ID）

#### 实战示例（模拟）

```sql
-- 雪花ID通常由应用程序生成，MySQL不原生支持
-- 这里演示如何存储

CREATE TABLE users (
    id BIGINT UNSIGNED PRIMARY KEY COMMENT '雪花ID',
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 应用程序生成雪花ID后插入
INSERT INTO users (id, username, email) VALUES
(1234567890123456789, 'zhangsan', 'zhangsan@example.com'),
(1234567890123456790, 'lisi', 'lisi@example.com');

SELECT * FROM users ORDER BY id;
-- ID是有序的，因为包含时间戳
```

#### 雪花ID生成（伪代码）

```python
# Python示例（需要使用第三方库）
from snowflake import SnowflakeGenerator

# 初始化生成器（数据中心ID=1，机器ID=1）
gen = SnowflakeGenerator(datacenter_id=1, worker_id=1)

# 生成ID
user_id = next(gen)  # 1234567890123456789

# 插入数据库
cursor.execute(
    "INSERT INTO users (id, username, email) VALUES (%s, %s, %s)",
    (user_id, 'zhangsan', 'zhangsan@example.com')
)
```

#### 雪花ID的优缺点

**优点**：
- ✅ 全局唯一
- ✅ 时间有序，插入性能好
- ✅ 占用空间小（8字节）
- ✅ 可反解析时间信息

**缺点**：
- ❌ 依赖系统时钟（时钟回拨会有问题）
- ❌ 需要额外的ID生成服务
- ❌ 需要分配机器ID

#### 最佳实践

```sql
-- ✅ 推荐：分布式系统使用雪花ID
CREATE TABLE users (
    id BIGINT UNSIGNED PRIMARY KEY COMMENT '雪花ID',
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 适用场景：
-- 1. 分布式系统
-- 2. 大型系统（需要高性能）
-- 3. 需要时间有序的ID
-- 4. 需要从ID反解析时间信息
```

---

### 1.6 方案四：复合主键

#### 特点

- 多个字段组合作为主键
- 适用于关联表
- 占用空间较大

#### 实战示例

```sql
-- 示例1：用户-角色关联表
CREATE TABLE user_roles (
    user_id BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
    role_id BIGINT UNSIGNED NOT NULL COMMENT '角色ID',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 复合主键
    PRIMARY KEY (user_id, role_id),

    INDEX idx_role_id (role_id)
) ENGINE=InnoDB COMMENT='用户角色关联表';

-- 插入数据
INSERT INTO user_roles (user_id, role_id) VALUES
(1, 1),  -- 用户1 -> 角色1
(1, 2),  -- 用户1 -> 角色2
(2, 1);  -- 用户2 -> 角色1

-- (1, 1)是唯一的，不能重复插入
INSERT INTO user_roles (user_id, role_id) VALUES (1, 1);
-- ERROR: Duplicate entry '1-1' for key 'PRIMARY'

-- 示例2：文章-标签关联表
CREATE TABLE article_tags (
    article_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (article_id, tag_id),
    INDEX idx_tag_id (tag_id)
) ENGINE=InnoDB;
```

#### 复合主键 vs 自增ID

```sql
-- 方式1：复合主键（推荐）
CREATE TABLE user_roles (
    user_id BIGINT UNSIGNED NOT NULL,
    role_id BIGINT UNSIGNED NOT NULL,
    PRIMARY KEY (user_id, role_id)
);

-- 方式2：自增ID（不推荐，冗余）
CREATE TABLE user_roles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,  -- 冗余字段
    user_id BIGINT UNSIGNED NOT NULL,
    role_id BIGINT UNSIGNED NOT NULL,
    UNIQUE KEY uniq_user_role (user_id, role_id)  -- 实际的唯一性约束
);

-- 复合主键优点：
-- 1. 节省空间（少一个字段）
-- 2. 语义清晰
-- 3. 查询效率高（主键即是查询条件）

-- 复合主键缺点：
-- 1. JOIN时需要两个字段
-- 2. 外键引用复杂
```

#### 最佳实践

```sql
-- ✅ 推荐：多对多关联表使用复合主键
CREATE TABLE article_tags (
    article_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (article_id, tag_id),
    INDEX idx_tag_id (tag_id)
) ENGINE=InnoDB;

-- ✅ 如果需要额外字段，考虑自增ID
CREATE TABLE user_roles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    role_id BIGINT UNSIGNED NOT NULL,
    granted_by BIGINT UNSIGNED NOT NULL COMMENT '授权人',
    granted_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_user_role (user_id, role_id),
    INDEX idx_role_id (role_id)
) ENGINE=InnoDB;
```

---

### 1.7 主键设计建议总结

| 场景 | 推荐方案 | 理由 |
|------|---------|------|
| 单体应用、中小型系统 | 自增ID | 简单、性能好 |
| 分布式系统、大型系统 | 雪花ID | 全局唯一、时间有序、性能好 |
| 需要离线生成ID | UUID（有序） | 无需中心化生成 |
| 多对多关联表 | 复合主键 | 语义清晰、节省空间 |

---

## 二、唯一索引设计

### 2.1 唯一索引的作用

**唯一索引（UNIQUE INDEX）**：
- 保证字段值的唯一性
- 自动创建索引，提高查询效率
- 允许NULL值（NULL != NULL）

### 2.2 单列唯一索引

#### 实战示例

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(20) NOT NULL DEFAULT '',

    -- 唯一索引
    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email),
    UNIQUE KEY uniq_phone (phone)
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO users (username, email, phone) VALUES
('zhangsan', 'zhangsan@example.com', '13800138000');

-- 尝试插入重复数据
INSERT INTO users (username, email, phone) VALUES
('zhangsan', 'zhangsan2@example.com', '13800138001');
-- ERROR: Duplicate entry 'zhangsan' for key 'uniq_username'

-- NULL值处理
INSERT INTO users (username, email, phone) VALUES
('lisi', 'lisi@example.com', '');    -- ✅ 可以插入
INSERT INTO users (username, email, phone) VALUES
('wangwu', 'wangwu@example.com', '');  -- ✅ 可以插入（空字符串不是NULL）

-- 如果phone允许NULL
ALTER TABLE users MODIFY phone VARCHAR(20) DEFAULT NULL;

INSERT INTO users (username, email, phone) VALUES
('zhaoliu', 'zhaoliu@example.com', NULL);   -- ✅ 可以插入
INSERT INTO users (username, email, phone) VALUES
('sunqi', 'sunqi@example.com', NULL);       -- ✅ 可以插入（NULL != NULL）
```

### 2.3 联合唯一索引

#### 实战示例

```sql
-- 示例：用户每天只能签到一次
CREATE TABLE user_sign_logs (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    sign_date DATE NOT NULL,
    points INT UNSIGNED NOT NULL DEFAULT 1,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 联合唯一索引：(user_id, sign_date) 组合唯一
    UNIQUE KEY uniq_user_sign (user_id, sign_date),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB COMMENT='用户签到记录表';

-- 插入数据
INSERT INTO user_sign_logs (user_id, sign_date, points) VALUES
(1, '2024-01-01', 1);  -- ✅ 成功

INSERT INTO user_sign_logs (user_id, sign_date, points) VALUES
(1, '2024-01-01', 1);  -- ❌ 失败：重复签到

INSERT INTO user_sign_logs (user_id, sign_date, points) VALUES
(1, '2024-01-02', 1);  -- ✅ 成功：不同日期

INSERT INTO user_sign_logs (user_id, sign_date, points) VALUES
(2, '2024-01-01', 1);  -- ✅ 成功：不同用户
```

#### 联合唯一索引的顺序

```sql
-- 索引顺序：高选择性字段在前
CREATE TABLE user_favorites (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    article_id BIGINT UNSIGNED NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- ✅ 推荐：user_id在前（假设每个用户收藏的文章不多）
    UNIQUE KEY uniq_user_article (user_id, article_id),

    -- 如果经常通过article_id查询，添加普通索引
    INDEX idx_article_id (article_id)
) ENGINE=InnoDB;

-- 查询：这个索引可以用
SELECT * FROM user_favorites WHERE user_id = 1 AND article_id = 100;
SELECT * FROM user_favorites WHERE user_id = 1;  -- ✅ 可以使用索引（最左前缀）

-- 查询：这个索引不能用（不满足最左前缀）
SELECT * FROM user_favorites WHERE article_id = 100;  -- ❌ 需要额外的索引
```

### 2.4 唯一索引 vs 主键

| 特性 | 主键 | 唯一索引 |
|------|------|---------|
| 唯一性 | ✅ | ✅ |
| 允许NULL | ❌ | ✅（但NULL != NULL） |
| 数量限制 | 每表1个 | 每表多个 |
| 聚簇索引 | ✅（InnoDB） | ❌ |

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,  -- 主键：不允许NULL，聚簇索引
    username VARCHAR(50) NOT NULL,

    UNIQUE KEY uniq_username (username)  -- 唯一索引：允许NULL（但username NOT NULL）
) ENGINE=InnoDB;
```

---

## 三、普通索引设计

### 3.1 普通索引的作用

**普通索引（INDEX）**：
- 提高查询效率
- 允许重复值
- 允许NULL值

### 3.2 单列索引

#### 何时需要索引

```sql
-- ✅ 需要索引的场景：

-- 1. WHERE条件字段
SELECT * FROM users WHERE status = 1;
-- 需要：INDEX idx_status (status)

-- 2. ORDER BY字段
SELECT * FROM users ORDER BY created_at DESC LIMIT 10;
-- 需要：INDEX idx_created_at (created_at)

-- 3. JOIN字段
SELECT * FROM orders o
JOIN order_items oi ON o.id = oi.order_id;
-- order_items表需要：INDEX idx_order_id (order_id)

-- 4. GROUP BY字段
SELECT city, COUNT(*) FROM users GROUP BY city;
-- 需要：INDEX idx_city (city)
```

#### 何时不需要索引

```sql
-- ❌ 不需要索引的场景：

-- 1. 低选择性字段（重复值多）
gender TINYINT UNSIGNED  -- 只有0/1/2，不需要索引

-- 2. 小表（数据量少）
-- 数据量 < 1000行，全表扫描可能更快

-- 3. 频繁更新的字段
-- 更新字段会导致索引更新，影响性能

-- 4. 很少查询的字段
remark TEXT  -- 很少作为查询条件，不需要索引
```

#### 实战示例

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(20) NOT NULL DEFAULT '',
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    city VARCHAR(50) NOT NULL DEFAULT '',
    age TINYINT UNSIGNED NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 唯一索引
    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email),

    -- 普通索引
    INDEX idx_phone (phone),        -- 查询条件
    INDEX idx_status (status),      -- 查询条件、过滤
    INDEX idx_city (city),          -- 查询条件、分组
    INDEX idx_created_at (created_at)  -- 排序、时间范围查询
) ENGINE=InnoDB;

-- 使用索引的查询
EXPLAIN SELECT * FROM users WHERE phone = '13800138000';
-- key: idx_phone

EXPLAIN SELECT * FROM users WHERE status = 1;
-- key: idx_status

EXPLAIN SELECT * FROM users ORDER BY created_at DESC LIMIT 10;
-- key: idx_created_at
```

### 3.3 联合索引（复合索引）

#### 最左前缀原则

```sql
-- 创建联合索引
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    city VARCHAR(50) NOT NULL,
    age TINYINT UNSIGNED NOT NULL DEFAULT 0,
    gender TINYINT UNSIGNED NOT NULL DEFAULT 0,

    -- 联合索引：(city, age, gender)
    INDEX idx_city_age_gender (city, age, gender)
) ENGINE=InnoDB;

-- ✅ 可以使用索引的查询（符合最左前缀）
SELECT * FROM users WHERE city = '北京';
SELECT * FROM users WHERE city = '北京' AND age = 25;
SELECT * FROM users WHERE city = '北京' AND age = 25 AND gender = 1;
SELECT * FROM users WHERE city = '北京' AND gender = 1;  -- 只用到(city)

-- ❌ 不能使用索引的查询（不符合最左前缀）
SELECT * FROM users WHERE age = 25;
SELECT * FROM users WHERE gender = 1;
SELECT * FROM users WHERE age = 25 AND gender = 1;
```

#### 联合索引的顺序

**原则**：
1. **高选择性字段在前**（区分度高的字段）
2. **等值查询字段在前，范围查询字段在后**
3. **查询频率高的字段在前**

```sql
-- 示例1：选择性排序
-- 假设：city有100个不同值，age有80个不同值，gender只有3个值
-- 选择性：city > age > gender

-- ✅ 推荐顺序
INDEX idx_city_age_gender (city, age, gender)

-- ❌ 不推荐
INDEX idx_gender_age_city (gender, age, city)  -- gender选择性低，放前面浪费

-- 示例2：等值 vs 范围
-- 查询：WHERE city = '北京' AND age > 20

-- ✅ 推荐：等值在前
INDEX idx_city_age (city, age)

-- ❌ 不推荐：范围在前
INDEX idx_age_city (age, city)  -- age是范围查询，后面的city可能用不上
```

#### 实战示例：电商商品查询

```sql
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    category_id BIGINT UNSIGNED NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    sales_count INT UNSIGNED NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 联合索引设计

    -- 常见查询1：分类 + 状态 + 价格排序
    -- SELECT * FROM products WHERE category_id = 1 AND status = 1 ORDER BY price_cents;
    INDEX idx_category_status_price (category_id, status, price_cents),

    -- 常见查询2：分类 + 状态 + 销量排序
    -- SELECT * FROM products WHERE category_id = 1 AND status = 1 ORDER BY sales_count DESC;
    INDEX idx_category_status_sales (category_id, status, sales_count),

    -- 其他索引
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB;

-- 测试查询
EXPLAIN SELECT * FROM products
WHERE category_id = 1 AND status = 1
ORDER BY price_cents LIMIT 10;
-- key: idx_category_status_price
-- Extra: Using index condition（理想情况）
```

### 3.4 覆盖索引

**覆盖索引**：查询的列都在索引中，无需回表查询

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username),
    INDEX idx_status_created (status, created_at)
) ENGINE=InnoDB;

-- ✅ 覆盖索引查询（无需回表）
SELECT id, status, created_at
FROM users
WHERE status = 1 AND created_at > '2024-01-01';
-- Extra: Using index（覆盖索引）

-- ❌ 非覆盖索引查询（需要回表）
SELECT id, status, created_at, email
FROM users
WHERE status = 1 AND created_at > '2024-01-01';
-- Extra: NULL（需要回表获取email）

-- 优化：将email加入索引（如果查询频繁）
INDEX idx_status_created_email (status, created_at, email)
-- 但会增加索引空间，需权衡
```

---

## 四、索引设计原则

### 4.1 索引设计的总体原则

1. **选择性高的字段优先**
2. **WHERE、ORDER BY、GROUP BY的字段优先**
3. **JOIN的字段必须索引**
4. **联合索引优于多个单列索引**
5. **控制索引数量（一般不超过5个）**
6. **避免过长的索引键**
7. **考虑索引的维护成本**

### 4.2 索引数量控制

```sql
-- ❌ 索引过多（维护成本高）
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    city VARCHAR(50),
    age TINYINT UNSIGNED,
    status TINYINT UNSIGNED,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email),
    INDEX idx_phone (phone),
    INDEX idx_city (city),
    INDEX idx_age (age),
    INDEX idx_status (status),
    INDEX idx_city_age (city, age),
    INDEX idx_city_status (city, status),
    INDEX idx_age_status (age, status)  -- 索引过多！
) ENGINE=InnoDB;

-- ✅ 合理的索引设计
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    city VARCHAR(50),
    age TINYINT UNSIGNED,
    status TINYINT UNSIGNED,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email),
    INDEX idx_phone (phone),
    INDEX idx_city_age_status (city, age, status)  -- 一个联合索引代替多个
) ENGINE=InnoDB;
```

### 4.3 索引长度控制

```sql
-- ❌ 索引键过长
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(500) NOT NULL,

    INDEX idx_title (title)  -- 索引键过长（500字节 * 4 = 2000字节）
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ✅ 使用前缀索引
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(500) NOT NULL,

    INDEX idx_title (title(100))  -- 只索引前100个字符
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 前缀长度选择
-- 计算选择性
SELECT
    COUNT(DISTINCT LEFT(title, 10)) / COUNT(*) AS sel_10,
    COUNT(DISTINCT LEFT(title, 20)) / COUNT(*) AS sel_20,
    COUNT(DISTINCT LEFT(title, 50)) / COUNT(*) AS sel_50,
    COUNT(DISTINCT LEFT(title, 100)) / COUNT(*) AS sel_100,
    COUNT(DISTINCT title) / COUNT(*) AS sel_full
FROM articles;

-- 选择性接近1的最小长度即可
```

---

## 五、实战案例

### 案例1：电商订单表索引设计

```sql
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,
    total_amount BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    paid_at DATETIME DEFAULT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 唯一索引
    UNIQUE KEY uniq_order_no (order_no),

    -- 普通索引
    INDEX idx_user_id (user_id),                        -- 查询某用户的订单
    INDEX idx_status (status),                          -- 按状态查询
    INDEX idx_user_status_created (user_id, status, created_at),  -- 用户订单列表
    INDEX idx_paid_at (paid_at),                        -- 支付时间查询
    INDEX idx_created_at (created_at)                   -- 创建时间查询
) ENGINE=InnoDB;

-- 常见查询及索引使用

-- 1. 查询某用户的所有订单
SELECT * FROM orders WHERE user_id = 1;
-- 使用：idx_user_id

-- 2. 查询某用户的待支付订单
SELECT * FROM orders WHERE user_id = 1 AND status = 1;
-- 使用：idx_user_status_created

-- 3. 查询某用户最近的订单
SELECT * FROM orders WHERE user_id = 1 ORDER BY created_at DESC LIMIT 10;
-- 使用：idx_user_status_created（覆盖部分）

-- 4. 查询今天的已支付订单
SELECT * FROM orders WHERE status = 2 AND paid_at > '2024-01-01';
-- 使用：idx_status 或 idx_paid_at

-- 5. 根据订单号查询
SELECT * FROM orders WHERE order_no = 'ORDER123456';
-- 使用：uniq_order_no
```

### 案例2：社交应用的关注表

```sql
CREATE TABLE user_follows (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    follower_id BIGINT UNSIGNED NOT NULL COMMENT '关注者ID',
    followee_id BIGINT UNSIGNED NOT NULL COMMENT '被关注者ID',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 唯一索引：防止重复关注
    UNIQUE KEY uniq_follower_followee (follower_id, followee_id),

    -- 普通索引：查询某人的粉丝
    INDEX idx_followee_id (followee_id),

    -- 联合索引：查询关注列表（按时间排序）
    INDEX idx_follower_created (follower_id, created_at)
) ENGINE=InnoDB;

-- 常见查询

-- 1. A关注B（插入）
INSERT INTO user_follows (follower_id, followee_id) VALUES (1, 2);
-- 使用：uniq_follower_followee（检查重复）

-- 2. 查询A的关注列表
SELECT followee_id FROM user_follows WHERE follower_id = 1 ORDER BY created_at DESC;
-- 使用：idx_follower_created

-- 3. 查询B的粉丝列表
SELECT follower_id FROM user_follows WHERE followee_id = 2 ORDER BY created_at DESC;
-- 使用：idx_followee_id

-- 4. 判断A是否关注B
SELECT COUNT(*) FROM user_follows WHERE follower_id = 1 AND followee_id = 2;
-- 使用：uniq_follower_followee

-- 5. 互相关注（A关注B，且B关注A）
SELECT f1.follower_id, f1.followee_id
FROM user_follows f1
JOIN user_follows f2 ON f1.follower_id = f2.followee_id AND f1.followee_id = f2.follower_id;
```

---

## 六、练习题

### 练习1：设计文章表的索引

**表结构**：
```sql
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    author_id BIGINT UNSIGNED NOT NULL,
    category_id BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,  -- 1-草稿，2-已发布
    view_count INT UNSIGNED NOT NULL DEFAULT 0,
    published_at DATETIME DEFAULT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;
```

**常见查询**：
1. 查询某作者的所有文章
2. 查询某分类下已发布的文章（按发布时间倒序）
3. 查询热门文章（按浏览量倒序）
4. 查询最新发布的文章

**请设计索引**，参考答案见文末。

### 练习2：设计商品评论表的索引

**表结构**：
```sql
CREATE TABLE product_reviews (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT UNSIGNED NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,
    rating TINYINT UNSIGNED NOT NULL,  -- 1-5星
    content TEXT,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,  -- 1-待审核，2-已通过
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;
```

**常见查询**：
1. 查询某商品的所有评论（已通过审核，按时间倒序）
2. 查询某用户的所有评论
3. 查询某商品的好评（4-5星）

**请设计索引**，参考答案见文末。

---

## 七、本章总结

### 核心要点

1. **主键设计**：
   - 单体应用：自增ID（BIGINT UNSIGNED）
   - 分布式系统：雪花ID
   - 多对多关联表：复合主键

2. **唯一索引**：
   - 唯一性约束字段：username、email、phone
   - 联合唯一：防止重复的组合

3. **普通索引**：
   - WHERE、ORDER BY、GROUP BY字段
   - JOIN字段
   - 联合索引优于多个单列索引
   - 遵循最左前缀原则

4. **索引设计原则**：
   - 够用即可，避免过度索引
   - 高选择性字段优先
   - 控制索引数量和长度

### 下一步

完成本章学习后，你应该能够：
- ✅ 为不同场景选择合适的主键策略
- ✅ 设计唯一索引保证数据唯一性
- ✅ 设计普通索引提高查询效率
- ✅ 理解联合索引和最左前缀原则

下一章我们将学习 **表关系设计**，深入理解一对一、一对多、多对多关系的设计方法。

---

## 八、练习题参考答案

### 练习1答案

```sql
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    author_id BIGINT UNSIGNED NOT NULL,
    category_id BIGINT UNSIGNED NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    view_count INT UNSIGNED NOT NULL DEFAULT 0,
    published_at DATETIME DEFAULT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 索引设计

    -- 1. 查询某作者的所有文章
    INDEX idx_author_id (author_id),

    -- 2. 查询某分类下已发布的文章（按发布时间倒序）
    INDEX idx_category_status_published (category_id, status, published_at),

    -- 3. 查询热门文章（按浏览量倒序）
    INDEX idx_view_count (view_count),

    -- 4. 查询最新发布的文章
    INDEX idx_status_published (status, published_at),

    -- 通用时间索引
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB;
```

### 练习2答案

```sql
CREATE TABLE product_reviews (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT UNSIGNED NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,
    rating TINYINT UNSIGNED NOT NULL,
    content TEXT,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- 索引设计

    -- 1. 查询某商品的所有评论（已通过审核，按时间倒序）
    INDEX idx_product_status_created (product_id, status, created_at),

    -- 2. 查询某用户的所有评论
    INDEX idx_user_id (user_id),

    -- 3. 查询某商品的好评（4-5星）
    INDEX idx_product_rating (product_id, rating),

    -- 防止重复评论（可选）
    UNIQUE KEY uniq_product_user (product_id, user_id)
) ENGINE=InnoDB;
```

---

**🎉 恭喜完成第二节学习！**

下一节：[03-表关系设计](./03-表关系设计.md)

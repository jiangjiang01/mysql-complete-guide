# 05-常用表设计模式

> 掌握软删除、时间戳、状态字段等实用设计模式

---

## 📖 本章目标

- 掌握软删除的设计方法
- 掌握时间戳字段的设计
- 掌握状态字段的设计
- 掌握版本号和乐观锁的设计
- 掌握扩展字段的设计方法

---

## 一、软删除设计

### 1.1 为什么需要软删除

**硬删除的问题**：
```sql
-- 硬删除：物理删除数据
DELETE FROM users WHERE id = 1;

-- 问题：
-- 1. 数据无法恢复
-- 2. 关联数据处理复杂（订单、评论等）
-- 3. 无法追溯历史
-- 4. 可能违反合规要求（数据保留政策）
```

**软删除的优点**：
- ✅ 数据可恢复
- ✅ 保留历史记录
- ✅ 符合数据保留要求
- ✅ 关联数据处理简单

### 1.2 方案一：deleted_at 时间戳

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    -- 软删除字段：删除时间
    deleted_at DATETIME DEFAULT NULL COMMENT '删除时间，NULL表示未删除',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email),
    INDEX idx_deleted_at (deleted_at)
) ENGINE=InnoDB;

-- 软删除
UPDATE users SET deleted_at = NOW() WHERE id = 1;

-- 查询未删除的用户
SELECT * FROM users WHERE deleted_at IS NULL;

-- 查询已删除的用户
SELECT * FROM users WHERE deleted_at IS NOT NULL;

-- 恢复删除的用户
UPDATE users SET deleted_at = NULL WHERE id = 1;

-- 永久删除（定期清理）
DELETE FROM users WHERE deleted_at < DATE_SUB(NOW(), INTERVAL 90 DAY);
```

**优点**：
- ✅ 记录删除时间
- ✅ 可按时间查询删除记��
- ✅ 符合直觉

**缺点**：
- ❌ 唯一索引问题（见下文）

### 1.3 方案二：is_deleted 标志位

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    -- 软删除字段：删除标志
    is_deleted TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '是否删除��0-否，1-是',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email),
    INDEX idx_is_deleted (is_deleted)
) ENGINE=InnoDB;

-- 软删除
UPDATE users SET is_deleted = 1 WHERE id = 1;

-- 查询未删除的用户
SELECT * FROM users WHERE is_deleted = 0;

-- 查询已删除的用户
SELECT * FROM users WHERE is_deleted = 1;

-- 恢复删除的用户
UPDATE users SET is_deleted = 0 WHERE id = 1;
```

**优点**：
- ✅ 查询简单
- ✅ 索引占用空间小

**缺点**：
- ❌ 不记录删除时间

### 1.4 方案三：status 状态字段

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    -- 状态字段（包含删除状态）
    status TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '状态：1-正常，2-禁用，3-已删除',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at DATETIME DEFAULT NULL COMMENT '删除时间',

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email),
    INDEX idx_status (status)
) ENGINE=InnoDB;

-- 软删除
UPDATE users
SET status = 3, deleted_at = NOW()
WHERE id = 1;

-- 查询未删除的用户
SELECT * FROM users WHERE status != 3;
-- 或
SELECT * FROM users WHERE status IN (1, 2);

-- 查询已删除的用户
SELECT * FROM users WHERE status = 3;
```

**优点**：
- ✅ 支持多种状态
- ✅ 灵活性高

**缺点**：
- ❌ 查询条件复杂

### 1.5 软删除的唯一索引问题

```sql
-- 问题：软删除后，用户名被占用

CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    deleted_at DATETIME DEFAULT NULL,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 插入用户
INSERT INTO users (username) VALUES ('zhangsan');

-- 软删除
UPDATE users SET deleted_at = NOW() WHERE username = 'zhangsan';

-- 尝试用相同用户名注册
INSERT INTO users (username) VALUES ('zhangsan');
-- ERROR: Duplicate entry 'zhangsan' for key 'uniq_username'
```

**解决方案一：联合唯一索引（username, deleted_at）**

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    deleted_at DATETIME DEFAULT NULL,

    -- 联合唯一索引：(username, deleted_at)
    UNIQUE KEY uniq_username_deleted (username, deleted_at)
) ENGINE=InnoDB;

-- 插入用户
INSERT INTO users (username, deleted_at) VALUES ('zhangsan', NULL);

-- 软删除
UPDATE users SET deleted_at = NOW() WHERE username = 'zhangsan';

-- 可以用相同用户名注册（因为deleted_at不同）
INSERT INTO users (username, deleted_at) VALUES ('zhangsan', NULL);

-- 问题：可以删除多次同一个用户名（deleted_at不同）
UPDATE users SET deleted_at = NOW() WHERE username = 'zhangsan';  -- 第一次删除
INSERT INTO users (username) VALUES ('zhangsan');                 -- 重新注册
UPDATE users SET deleted_at = NOW() WHERE username = 'zhangsan';  -- 第二次删除
-- 现在有两条deleted_at不同的zhangsan记录
```

**解决方案二：删除时修改用户名**

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    deleted_at DATETIME DEFAULT NULL,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 软删除时，修改username
UPDATE users
SET
    username = CONCAT(username, '_deleted_', id),  -- zhangsan_deleted_1
    deleted_at = NOW()
WHERE id = 1;

-- 现在可以用原用户名注册
INSERT INTO users (username) VALUES ('zhangsan');
```

**解决方案三：使用is_deleted + 联合唯一索引**

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    is_deleted TINYINT UNSIGNED NOT NULL DEFAULT 0,

    -- 联合唯一索引：(username, is_deleted)
    -- 但只对is_deleted=0生效
    UNIQUE KEY uniq_username (username, is_deleted)
) ENGINE=InnoDB;

-- 问题：这个方案仍然有问题
-- 可以有多条is_deleted=1的相同username记录
```

**推荐方案：deleted_at + 修改唯一字段**

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    deleted_at DATETIME DEFAULT NULL,

    UNIQUE KEY uniq_username (username),
    UNIQUE KEY uniq_email (email)
) ENGINE=InnoDB;

-- 软删除：修改唯一字段
UPDATE users
SET
    username = CONCAT(username, '_deleted_', UNIX_TIMESTAMP(NOW())),
    email = CONCAT(email, '_deleted_', UNIX_TIMESTAMP(NOW())),
    deleted_at = NOW()
WHERE id = 1;

-- 查询时过滤
SELECT * FROM users WHERE deleted_at IS NULL;
```

---

## 二、时间戳设计

### 2.1 标准时间戳字段

```sql
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,

    -- 标准时间戳字段
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',

    INDEX idx_created_at (created_at)
) ENGINE=InnoDB;

-- 插入数据（自动记录created_at和updated_at）
INSERT INTO articles (title, content) VALUES
('标题1', '内容1');

-- 更新数据（自动更新updated_at）
UPDATE articles SET content = '新内容' WHERE id = 1;

-- 查询
SELECT id, title, created_at, updated_at FROM articles;
```

### 2.2 扩展时间戳字段

```sql
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,

    -- 基础时间戳
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    -- 业务时间戳
    published_at DATETIME DEFAULT NULL COMMENT '发布时间',
    deleted_at DATETIME DEFAULT NULL COMMENT '删除时间',

    INDEX idx_created_at (created_at),
    INDEX idx_published_at (published_at)
) ENGINE=InnoDB;

-- 发布文章
UPDATE articles
SET
    status = 2,
    published_at = NOW()
WHERE id = 1;

-- 查询已发布的文章
SELECT * FROM articles
WHERE status = 2
AND published_at IS NOT NULL
ORDER BY published_at DESC;
```

### 2.3 操作人字段

```sql
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,

    -- 时间戳 + 操作人
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT UNSIGNED NOT NULL COMMENT '创建人ID',

    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    updated_by BIGINT UNSIGNED DEFAULT NULL COMMENT '最后更新人ID',

    INDEX idx_created_by (created_by),
    INDEX idx_updated_by (updated_by)
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO articles (title, content, created_by) VALUES
('标题1', '内容1', 1);  -- 用户1创建

-- 更新数据
UPDATE articles
SET
    content = '新内容',
    updated_by = 2  -- 用户2更新
WHERE id = 1;
```

---

## 三、状态字段设计

### 3.1 ENUM vs TINYINT

**方案一：ENUM 类型**

```sql
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,

    -- ENUM类型
    status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled') NOT NULL DEFAULT 'pending',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO orders (order_no, status) VALUES
('ORDER001', 'pending');

-- 查询
SELECT * FROM orders WHERE status = 'paid';

-- 优点：
-- 1. 自解释，可读性好
-- 2. 数据库层面限制值

-- 缺点：
-- 1. 修改ENUM值需要ALTER TABLE
-- 2. 占用空间（1-2字节 + 字符串）
-- 3. 应用层难以维护常量
```

**方案二：TINYINT（推荐）**

```sql
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,

    -- TINYINT类型
    status TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '状态：1-待支付，2-已支付，3-已发货，4-已完成，5-已取消',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_status (status)
) ENGINE=InnoDB;

-- 应用层定义常量
-- Python示例
class OrderStatus:
    PENDING = 1      # 待支付
    PAID = 2         # 已支付
    SHIPPED = 3      # 已发货
    COMPLETED = 4    # 已完成
    CANCELLED = 5    # 已取消

-- 插入数据
INSERT INTO orders (order_no, status) VALUES
('ORDER001', 1);  -- OrderStatus.PENDING

-- 查询
SELECT * FROM orders WHERE status = 2;  -- OrderStatus.PAID

-- 优点：
-- 1. 占用空间小（1字节）
-- 2. 索引效率高
-- 3. 灵活，易扩展
-- 4. 应用层维护常量，清晰

-- 缺点：
-- 1. 可读性差（需要对照注释或常量）
```

**推荐做法：TINYINT + 详细注释**

```sql
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '状态：1-待支付，2-已支付，3-已发货，4-已完成，5-已取消',

    INDEX idx_status (status)
) ENGINE=InnoDB;
```

### 3.2 状态流转设计

```sql
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,
    user_id BIGINT UNSIGNED NOT NULL,

    -- 状态字段
    status TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '状态：1-待支付，2-已支��，3-已发货，4-已完成，5-已取消',

    -- 状态时间
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '下单时间',
    paid_at DATETIME DEFAULT NULL COMMENT '支付时间',
    shipped_at DATETIME DEFAULT NULL COMMENT '发货时间',
    completed_at DATETIME DEFAULT NULL COMMENT '完成时间',
    cancelled_at DATETIME DEFAULT NULL COMMENT '取消时间',

    UNIQUE KEY uniq_order_no (order_no),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status)
) ENGINE=InnoDB;

-- 状态流转

-- 1. 待支付 → 已支付
UPDATE orders
SET
    status = 2,
    paid_at = NOW()
WHERE id = 1 AND status = 1;

-- 2. 已支付 → 已发货
UPDATE orders
SET
    status = 3,
    shipped_at = NOW()
WHERE id = 1 AND status = 2;

-- 3. 已发货 → 已完成
UPDATE orders
SET
    status = 4,
    completed_at = NOW()
WHERE id = 1 AND status = 3;

-- 4. 任意状态 → 已取消
UPDATE orders
SET
    status = 5,
    cancelled_at = NOW()
WHERE id = 1 AND status IN (1, 2);  -- 只允许待支付、已支付取消
```

### 3.3 状态历史记录

```sql
-- 订单表
CREATE TABLE orders (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(32) NOT NULL,
    status TINYINT UNSIGNED NOT NULL DEFAULT 1,

    UNIQUE KEY uniq_order_no (order_no)
) ENGINE=InnoDB;

-- 订单状态日志表
CREATE TABLE order_status_logs (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,

    -- 状态变更
    old_status TINYINT UNSIGNED NOT NULL COMMENT '原状态',
    new_status TINYINT UNSIGNED NOT NULL COMMENT '新状态',

    -- 操作信息
    operator_id BIGINT UNSIGNED DEFAULT NULL COMMENT '操作人ID',
    remark VARCHAR(255) NOT NULL DEFAULT '' COMMENT '备注',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_order_id (order_id),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB COMMENT='订单状态变更日志';

-- 更新订单状态时，记录日志
BEGIN;

-- 获取原状态
SELECT @old_status := status FROM orders WHERE id = 1;

-- 更新状态
UPDATE orders SET status = 2, paid_at = NOW() WHERE id = 1;

-- 记录日志
INSERT INTO order_status_logs (order_id, old_status, new_status, operator_id, remark)
VALUES (1, @old_status, 2, 100, '用户支付成功');

COMMIT;

-- 查询订单的状态变更历史
SELECT
    old_status,
    new_status,
    operator_id,
    remark,
    created_at
FROM order_status_logs
WHERE order_id = 1
ORDER BY created_at;
```

---

## 四、版本号设计（乐观锁）

### 4.1 为什么需要版本号

**并发更新问题**：

```sql
-- 场景：两个用户同时修改文章

-- 用户A查询
SELECT id, title, content FROM articles WHERE id = 1;
-- 结果：title = "原标题", content = "原内容"

-- 用户B查询
SELECT id, title, content FROM articles WHERE id = 1;
-- 结果：title = "原标题", content = "原内容"

-- 用户A更新
UPDATE articles SET title = "标题A", content = "内容A" WHERE id = 1;

-- 用户B更新（覆盖了用户A的修改）
UPDATE articles SET title = "标题B", content = "内容B" WHERE id = 1;

-- 结果：用户A的修改丢失
```

### 4.2 乐观锁（版本号）

```sql
CREATE TABLE articles (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,

    -- 版本号
    version INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '版本号，用于乐观锁',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO articles (title, content, version) VALUES
('原标题', '原内容', 0);

-- 用户A查询
SELECT id, title, content, version FROM articles WHERE id = 1;
-- 结果：version = 0

-- 用户B查询
SELECT id, title, content, version FROM articles WHERE id = 1;
-- 结果：version = 0

-- 用户A更新（带版本号检查）
UPDATE articles
SET
    title = '标题A',
    content = '内容A',
    version = version + 1
WHERE id = 1 AND version = 0;
-- 影响行数：1（更新成功）

-- 用户B更新（版本号不匹配）
UPDATE articles
SET
    title = '标题B',
    content = '内容B',
    version = version + 1
WHERE id = 1 AND version = 0;
-- 影响行数：0（更新失败，版本号已经是1）

-- 应用层处理
affected_rows = execute_update(...)
if affected_rows == 0:
    # 更新失败，数据已被其他用户修改
    raise Exception("数据已被修改，请刷新后重试")
```

### 4.3 乐观锁应用：库存扣减

```sql
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL,

    -- 库存
    stock INT UNSIGNED NOT NULL DEFAULT 0,

    -- 版本号
    version INT UNSIGNED NOT NULL DEFAULT 0,

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- 插入商品
INSERT INTO products (name, price_cents, stock, version) VALUES
('iPhone 15', 599900, 100, 0);

-- 扣减库存（乐观锁）
UPDATE products
SET
    stock = stock - 1,
    version = version + 1
WHERE id = 1
AND stock >= 1          -- 库存充足
AND version = 0;        -- 版本号匹配

-- 检查影响行数
affected_rows = execute_update(...)
if affected_rows == 0:
    # 扣减失败（库存不足或版本号不匹配）
    raise Exception("扣减失败")
```

### 4.4 悲观锁（FOR UPDATE）

```sql
-- 悲观锁：锁定行，防止并发修改
BEGIN;

-- 查询并锁定
SELECT stock, version FROM products WHERE id = 1 FOR UPDATE;

-- 检查库存
IF stock >= 1:
    -- 扣减库存
    UPDATE products SET stock = stock - 1 WHERE id = 1;
    COMMIT;
ELSE:
    -- 库存不足
    ROLLBACK;
    raise Exception("库存不足");
```

**乐观锁 vs 悲观锁**：

| 方案 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| 乐观锁（version） | 读多写少、冲突少 | 性能好、无锁 | 需要重试逻辑 |
| 悲观锁（FOR UPDATE） | 写多、冲突多 | 保证成功 | 性能差、可能死锁 |

---

## 五、扩展字段设计

### 5.1 JSON字段

```sql
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL,

    -- JSON扩展字段
    attributes JSON COMMENT '商品属性（动态）',
    specifications JSON COMMENT '规格参数',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO products (name, price_cents, attributes, specifications) VALUES (
    'iPhone 15 Pro',
    899900,
    '{"color": "深空黑", "storage": "256GB", "network": "5G"}',
    '{"screen": "6.1英寸", "cpu": "A17 Pro", "camera": "4800万"}'
);

-- 查询
SELECT
    name,
    price_cents / 100 AS price,
    attributes->>'$.color' AS color,
    attributes->>'$.storage' AS storage,
    specifications->>'$.screen' AS screen
FROM products
WHERE id = 1;

-- 按JSON字段查询
SELECT * FROM products
WHERE JSON_EXTRACT(attributes, '$.color') = '深空黑';

-- 创建虚拟列索引
ALTER TABLE products
ADD COLUMN color VARCHAR(50) AS (attributes->>'$.color') VIRTUAL,
ADD INDEX idx_color (color);

-- 现在可以高效查询
SELECT * FROM products WHERE color = '深空黑';
```

**JSON字段的优缺点**：

**优点**：
- ✅ 灵活，无需修改表结构
- ✅ 适合动态属性

**缺点**：
- ❌ 查询性能差（除非使用虚拟列）
- ❌ 不易维护
- ❌ 不便于统计

### 5.2 EAV模型（实体-属性-值）

```sql
-- 商品表
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    price_cents BIGINT UNSIGNED NOT NULL
) ENGINE=InnoDB;

-- 属性表
CREATE TABLE attributes (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL COMMENT '属性名',
    type VARCHAR(20) NOT NULL COMMENT '类型：string/number/boolean',

    UNIQUE KEY uniq_name (name)
) ENGINE=InnoDB;

-- 商品属性值表（EAV）
CREATE TABLE product_attribute_values (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT UNSIGNED NOT NULL,
    attribute_id BIGINT UNSIGNED NOT NULL,
    value VARCHAR(255) NOT NULL,

    UNIQUE KEY uniq_product_attribute (product_id, attribute_id),
    INDEX idx_attribute_id (attribute_id)
) ENGINE=InnoDB;

-- 插入数据
INSERT INTO products (id, name, price_cents) VALUES (1, 'iPhone 15', 599900);

INSERT INTO attributes (id, name, type) VALUES
(1, 'color', 'string'),
(2, 'storage', 'string'),
(3, 'network', 'string');

INSERT INTO product_attribute_values (product_id, attribute_id, value) VALUES
(1, 1, '深空黑'),
(1, 2, '256GB'),
(1, 3, '5G');

-- 查询商品及属性
SELECT
    p.name,
    a.name AS attr_name,
    pav.value
FROM products p
JOIN product_attribute_values pav ON p.id = pav.product_id
JOIN attributes a ON pav.attribute_id = a.id
WHERE p.id = 1;

-- 结果：
-- iPhone 15 | color   | 深空黑
-- iPhone 15 | storage | 256GB
-- iPhone 15 | network | 5G
```

**EAV模型的优缺点**：

**优点**：
- ✅ 极度灵活
- ✅ 适合完全动态的属性

**缺点**：
- ❌ 查询复杂（多次JOIN）
- ❌ 性能差
- ❌ 数据类型约束弱

### 5.3 预留字段

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    -- 预留字段
    ext1 VARCHAR(255) NOT NULL DEFAULT '',
    ext2 VARCHAR(255) NOT NULL DEFAULT '',
    ext3 TEXT,

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 后续使用
-- ext1存储推荐人ID
-- ext2存储来源渠道
-- ext3存储备注信息
```

**预留字段的问题**：
- ❌ 字段名无意义
- ❌ 不知道存储什么类型
- ❌ 难以维护

**推荐做法**：使用JSON字段代替预留字段

```sql
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,

    -- JSON扩展字段（代替预留字段）
    extra JSON COMMENT '扩展信息',

    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE KEY uniq_username (username)
) ENGINE=InnoDB;

-- 使用
UPDATE users
SET extra = JSON_SET(IFNULL(extra, '{}'), '$.referrer_id', 100)
WHERE id = 1;
```

---

## 六、综合实战案例

### 案例：电商订单表完整设计

```sql
CREATE TABLE orders (
    -- 主键
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID',

    -- 业务字段
    order_no VARCHAR(32) NOT NULL COMMENT '订单号',
    user_id BIGINT UNSIGNED NOT NULL COMMENT '用户ID',

    -- 冗余字段
    username VARCHAR(50) NOT NULL COMMENT '用户名（冗余）',

    -- 金额（分）
    total_amount BIGINT UNSIGNED NOT NULL COMMENT '总金额（分）',
    pay_amount BIGINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '实付金额（分）',
    discount_amount BIGINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '优惠金额（分）',

    -- 状态字段
    status TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '状态：1-待支付，2-已支付，3-已发货，4-已完成，5-已取消',

    -- 支付方式
    pay_method TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '支付方式：0-未支付，1-微信，2-支付宝，3-余额',

    -- 状态时间
    paid_at DATETIME DEFAULT NULL COMMENT '支付时间',
    shipped_at DATETIME DEFAULT NULL COMMENT '发货时间',
    completed_at DATETIME DEFAULT NULL COMMENT '完成时间',
    cancelled_at DATETIME DEFAULT NULL COMMENT '取消时间',

    -- 收货地址（JSON快照）
    shipping_address JSON COMMENT '收货地址',

    -- 备注
    user_remark VARCHAR(255) NOT NULL DEFAULT '' COMMENT '用户备注',
    admin_remark VARCHAR(255) NOT NULL DEFAULT '' COMMENT '管理员备注',

    -- 版本号（乐观锁）
    version INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '版本号',

    -- 扩展字段
    extra JSON COMMENT '扩展信息',

    -- 时间戳
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',

    -- 软删除
    deleted_at DATETIME DEFAULT NULL COMMENT '删除时间',

    -- 索引
    UNIQUE KEY uniq_order_no (order_no),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_paid_at (paid_at),
    INDEX idx_created_at (created_at),
    INDEX idx_deleted_at (deleted_at)
) ENGINE=InnoDB COMMENT='订单表';
```

---

## 七、本章总结

### 核心要点

1. **软删除**：
   - 推荐：deleted_at（时间戳）
   - 唯一索引问题：修改唯一字段

2. **时间戳**：
   - 标准字段：created_at、updated_at
   - 业务字段：published_at、deleted_at
   - 操作人字段：created_by、updated_by

3. **状态字段**：
   - 推荐：TINYINT + 详细注释
   - 记录状态时间
   - 状态历史日志表

4. **版本号**：
   - 乐观锁：适合读多写少
   - 悲观锁：适合写多冲突多

5. **扩展字段**：
   - 推荐：JSON字段
   - 避免：无意义的预留字段

### 下一步

完成本章学习后，你应该能够：
- ✅ 实现软删除功能
- ✅ 设计完整的时间戳字段
- ✅ 设计状态字段和状态流转
- ✅ 使用版本号实现乐观锁
- ✅ 使用JSON字段扩展表结构

**🎉 恭喜完成第一章！**

下一章：[第二章 - 单表操作](./06-单表增删改查基础.md)
